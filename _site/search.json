[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction_to_Linux",
    "section": "",
    "text": "This is the homepage for the ‘Introduction to Bioinformatics on the Command Line’ course at the University of Edinburgh."
  },
  {
    "objectID": "00-intro.html",
    "href": "00-intro.html",
    "title": "Introduction",
    "section": "",
    "text": "This introductory course will teach you the basics of performing bioinformatics data analysis on the command line using the GNU bash shell. It covers the following topics:\n\nGetting started with bash\nRunning commands in bash\nNavigating the file system\nManaging files, directories and links\nManaging processes\nBioinformatics data analysis with bash\nCreating bash scripts for reproducible data analysis\n\n\n\nThe GNU bash shell\n\nThe GNU bash shell is one of a range of command line shells that are available for UNIX based operating systems. Modern alternatives include ZSH and the fish shell. Each of these shells provides a high level interface to UNIX based operating systems such as GNU/Linux.\nCommand line shells such as bash provide similar functionality to graphical user interfaces (GUIs), such as those seen in Microsoft Windows and Mac OS X, allowing users to do perform tasks such as navigating the file system, running programs, and managing processes and system settings.\n\n\n\nAdvantages of using a command line shell\n\nWhile command line shells such as bash are not as intuitive for beginners as the point and click interfaces offered by GUI shells, they offer a number of advantages which are very useful for Bioinformatics data analysis:\n\nFlexibility\n\nyou can log in and work on remote machines that may not have a graphical interface or remote desktop server installed\nyou can use bioinformatics tools that don’t have a GUI\n\nReliability\n\nCommand line interfaces take up less memory and system resources than graphical interfaces\nBecause of the complexity of GUI programming, tools with GUIs are more likely to contain bugs\n\nConvenience\n\nPrograms and documentation can be accessed easily\nbash keeps a history of the commands you run and makes it easy to repeat commands\n\nPower\n\nsimple programs can be combined to perform more complex functions\nyou can create scripts for data analysis, without the overhead of creating a GUI\n\n\n\n\n\nThe UNIX philosophy\n\nThe programs that you will use to interact with the computer using the GNU bash shell have been designed according to the UNIX philosophy, which has been summarised as follows:\n\nWrite programs that do one thing and do it well\nWrite programs to work together\nWrite programs to handle text streams, because that is a universal interface\n\nThis philosophy makes it possible to perform a wide range of complex data analysis tasks by combining a relatively small number of basic commands in different ways. Once you have mastered these basic commands, you’ll find that the bash shell provides an extremely powerful and useful way to manage bioinformatics analyses."
  },
  {
    "objectID": "05-analysis.html",
    "href": "05-analysis.html",
    "title": "Bioinformatics analysis on the command line",
    "section": "",
    "text": "In this section you will learn how to work with common Next Generation Sequencing (NGS) data formats on the command line.\n\n\nBioinformatics data formats and tools\n\n\n\n\n Key Points\n\n\nMany standard formats for storing high throughput sequencing data take the form of structured text files, which are easy to manipulate using standard GNU utilities\nMany powerful specialist tools for bioinformatics analysis have been developed to use these formats\n\n\n\nMany of the most common types of file that you will have to work with as a bioinformatician take the form of structured text files, examples include:\n\nStandard formats for representing raw sequences\n\nFASTA\nFASTQ\n\nTabular formats for representating aligned reads and features\n\nBED\nSAM\nbedGraph\n\n\nSome other compressed formats, such as BAM, which is a compressed version of the SAM format, can easily be converted to human readable text.\nFurthermore, numerous specialist bioinformatics tools have been specifically developed for working with these file formats. For example:\n\nbedtools and bedops, which work with BED files\nVarious aligners, such as STAR, hisat2, and others, which take raw sequences in FASTQ or FASTA format and align them to the genome\nsamtools, which works with SAM files and BAM files\n\nBAM files can be viewed in SAM format using the samtools view command\n\n\nNote: These tools are not included in most Linux distributions as standard and typically have to be installed separately.\n\n\n\nWorking with NGS data using GNU tools\n\n\n\n\n Key Points\n\n\nIt is possible to perform a wide range of complex analysis tasks on NGS data files using standard GNU utilities\nIn this section we illustrate the application of these tools to NGS data\n\n\n\nIn previous sections, we extracted an archive named bioinformatics_on_the_command_line_files.tar.gz into the ~/course directory, creating a directory called ~/course/bioinformatics_on_the_command_line_files. This directory contains a file called yeast_genes.bed, which lists the genomic co-ordinates of 7,126 yeast genes in BED format, and another file called yeast_genome.fasta, which contains the yeast EF4 genome sequence in FASTA format:\n\n[USERNAME]@bifx-core2:~/course$ head -5 bioinformatics_on_the_command_line_files/yeast_genes.bed\nchrI    334 649 YAL069W .   +\nchrI    537 792 YAL068W-A   .   +\nchrI    1806    2169    YAL068C .   -\nchrI    2479    2707    YAL067W-A   .   +\nchrI    7234    9016    YAL067C .   -\n[USERNAME]@bifx-core2:~/course$ head -5 bioinformatics_on_the_command_line_files/yeast_genome.fasta\n>I\nCCACACCACACCCACACACCCACACACCACACCACACACCACACCACACCCACACACACA\nCATCCTAACACTACCCTAACACAGCCCTAATCTAACCCTGGCCAACCTGTCTCTCAACTT\nACCCTCCATTACCCTGCCTCCACTCGTTACCCTGTCCCATTCAACCATACCACTCCGAAC\nCACCATCCATCCCTCTACTTACTACCACTCACCCACCGTTACCCTCCAATTACCCATATC\n[USERNAME]@bifx-core2:~/course$ \n\n\n\nChecking chromosome names in BED and FASTA files\nLooking at the above outputs, we can see that the naming convention for the chromosomes in the BED file (shown in the first column) appears to be different to the naming convention for the chromosomes in the FASTA file (shown in the first line after the > character). In order to confirm this we would like to produced a sorted list of chromosome names in each file and compare them. We can do this as follows:\n\n[USERNAME]@bifx-core2:~/course$ cd bioinformatics_on_the_command_line_files\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ cut -f1 yeast_genes.bed | sort -u > yeast_genes_bed_chromosomes.list \n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ grep -E '^>' yeast_genome.fasta | sort -u | cut -c2- > yeast_genome_fasta_chromosomes.list\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ wc -l *_chromosomes.list\n 17 yeast_genes_bed_chromosomes.list\n 17 yeast_genome_fasta_chromosomes.list\n 34 total\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ diff yeast_genes_bed_chromosomes.list yeast_genome_fasta_chromosomes.list \n1,17c1,17\n< chrI\n< chrII\n< chrIII\n< chrIV\n< chrIX\n< chrMT\n< chrV\n< chrVI\n< chrVII\n< chrVIII\n< chrX\n< chrXI\n< chrXII\n< chrXIII\n< chrXIV\n< chrXV\n< chrXVI\n---\n> I\n> II\n> III\n> IV\n> IX\n> MT\n> V\n> VI\n> VII\n> VIII\n> X\n> XI\n> XII\n> XIII\n> XIV\n> XV\n> XVI\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ \n\nThe above example demonstrates the following new commands:\n\ncut, which we used to select specified fields with the -f option, and specified characters with the -c option\nsort, which sorts the lines it receives from STDIN. The -u flag tells it to remove duplicate lines from the output\ndiff, which compares two text files, and outputs the differences between them\n\nAs a result of the commands we ran in the above example, we can see that there is a mismatch between the chromosome names in the BED and FASTA files. Each chromosome name in the BED file is equivalent to the corresponding name in the FASTA file with ‘chr’ added to the start.\nBefore using these files in a bioinformatics analysis, we need to update one of them so that the names match. In the following example we fix the BED file by removing ‘chr’ from the start of each line.\n\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ sed 's/^chr//' yeast_genes.bed > yeast_genes.fixed.bed\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ cut -f1 yeast_genes.fixed.bed | sort -u > yeast_genes_fixed_bed_chromosomes.list\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ diff yeast_genes_fixed_bed_chromosomes.list yeast_genome_fasta_chromosomes.list\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ rm -i *.list\nrm: remove regular file 'yeast_genes_bed_chromosomes.list'? y\nrm: remove regular file 'yeast_genes_fixed_bed_chromosomes.list'? y\nrm: remove regular file 'yeast_genome_fasta_chromosomes.list'? y\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ \n\nThis example uses the sed command, which is used to perform a search and replace style substitution on each line in the BED file using a regular expression (reminiscent of the prename command we saw earlier). Here, as in the previous examples using grep -E, the ‘^’ character is a regular expression character representing the start of the line. We then confirm that the chromosomes are now the same using the diff command. This produces no output, which means that there are no differences between the chromosome lists.\n\n\n\nManipulating BED files with awk and sort\nMany standard formats for representing NGS data take the form of tabular files, in which each line contains a number of fields, separated by a particular character (generally a tab character). The yeast_genes.fixed.bed file generated in the previous example fits this pattern.\nThis example demonstrates how to use awk and sort to find the name and length of the longest gene on chromosome ‘I’ in the yeast_genes.fixed.bed file:\n\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ awk -F'\\t' -v OFS='\\t' '$1==\"I\" {print $4,$3-$2}' yeast_genes.fixed.bed | sort -k2,2nr | head -1\nYAR050W 4614\n[USERNAME]@bifx-core2:~/course/bioinformatics_on_the_command_line_files$ cd ..\n[USERNAME]@bifx-core2:~/course$\n\nThe above example showcases the power of awk in dealing with tabular data. The command awk -F'\\t' -v OFS='\\t' '$1==\"I\" {print $4,$3-$2}' can be decomposed as follows:\n\n-F'\\t' tells awk that the field separator in the input lines is the tab character (\\t)\n-v OFS='\\t' tells awk that the tab character should also be used to separate the fields in the output file\n'$1==\"I\" {print $4,$3-$2}' is an awk program consisting of a single line. Each line of an awk program is a pair with the structure condition {action}, and the program is run on each line of the input. In this example:\n\nThe condition is $1==\"I\", which tells awk that the action should be performed if the first field is equal to “I”\nThe action is print $4,$3-$2, which tells awk to output a line to STDOUT in which the first field is the 4th field of the input line, and the second field is the result of subtracting the 2nd field from the 3rd. In this case the result is the gene length\n\n\nNote: A good resource to learn more about awk is Effective AWK Programming.\nThe sort command in the above example includes the option -k2,2nr. -k tells sort to sort by a key, which comprises a start and stop column number, followed by two options, n, which tells sort that the column contains numbers, and r, which tells sort that the lines should be sorted in reverse (i.e. descending) order.\n\n\n\n Challenge:\n\nHow could you remove ‘chr’ from the start of each line of yeast_genes.bed without using sed?\n\n\n\n\nSolution. \n\n Solution:\n\nSince we know that ‘chr’ is at the start of every line, cut -c4- yeast_genes.bed would also work.\n\n\n\n\n\n\n Challenge:\n\nHow would you find the shortest gene on the plus strand of chromosome ‘II’ in yeast_genes.fixed.bed?\n\n\n\n\nSolution. \n\n Solution:\n\nYou could run awk -F'\\t' -v OFS='\\t' '$1==\"II\"&&$6==\"+\" {print $4,$3-$2}' yeast_genes.fixed.bed | sort -k2,2n | head -1\n\n\n\n\n\n\n\n\nCase study: a simple RNA-Seq analysis workflow\n\n\n\n\n Key Points\n\n\nIt is possible to perform a simple bioinformatics analysis from end to end using only the bash command line\nThis section presents a simple case study using the STAR aligner and bedtools\n\n\n\nIn this section, we will work through a simple pipeline for analysing RNA-Seq data, which involves the following steps:\n\nStart with unaligned reads in FASTQ format\nAlign the reads against an index generated from a target genome, whose sequence is stored in FASTA format, obtaining an output file in BAM format\n\nHere we use the yeast EF4 genome, and align the reads using STAR\n\nCompute the genome coverage of the aligned reads, obtaining an output file in bedGraph format, which can then be viewed in a genome browser\n\nHere we generate the bedGraph file directly from the BED file using bedtools\n\nCount the overlaps between the aligned reads and genomic features, stored in BED format, obtaining an output file in BED format, and find the genes with the largest number of overlapping reads\n\nHere we use bedtools to compute the intersection between the genes and the reference, and use standard GNU utilities to find the genes with the most hits\n\n\nThis analysis uses the files in the ‘bioinformatics_on_the_command_line_files’ directory that we have already been working with, and can be performed as follows:\n\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── bioinformatics_on_the_command_line_files\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── README\n│   ├── yeast_genes.bed\n│   ├── yeast_genes.fixed.bed\n│   ├── yeast_genome.fasta\n│   └── yeast_genome.fasta.gz\n└── bioinformatics_on_the_command_line_files.tar.gz\n\n1 directory, 7 files\n[USERNAME]@bifx-core2:~/course$ mkdir analysis\n[USERNAME]@bifx-core2:~/course$ cd analysis\n[USERNAME]@bifx-core2:~/course/analysis$ mkdir 00_source_data\n[USERNAME]@bifx-core2:~/course/analysis$ cd 00_source_data\n[USERNAME]@bifx-core2:~/course/analysis/00_source_data$ ln -s ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq \n[USERNAME]@bifx-core2:~/course/analysis/00_source_data$ cd ..\n[USERNAME]@bifx-core2:~/course/analysis$ tree\n.\n└── 00_source_data\n    └── raw_yeast_rnaseq_data.fastq -> ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n\n1 directory, 1 file\n[USERNAME]@bifx-core2:~/course/analysis$ mkdir 01_star_index\n[USERNAME]@bifx-core2:~/course/analysis$ cd 01_star_index\n[USERNAME]@bifx-core2:~/course/analysis/01_star_index$ ln -s ../../bioinformatics_on_the_command_line_files/yeast_genome.fasta\n[USERNAME]@bifx-core2:~/course/analysis/01_star_index$ nice STAR --runThreadN 5 --runMode genomeGenerate --genomeDir . --genomeFastaFiles ./yeast_genome.fasta --genomeSAindexNbases 10\nNov 16 15:19:40 ..... started STAR run\nNov 16 15:19:40 ... starting to generate Genome files\nNov 16 15:19:40 ... starting to sort Suffix Array. This may take a long time...\nNov 16 15:19:41 ... sorting Suffix Array chunks and saving them to disk...\nNov 16 15:19:48 ... loading chunks from disk, packing SA...\nNov 16 15:19:49 ... finished generating suffix array\nNov 16 15:19:49 ... generating Suffix Array index\nNov 16 15:19:50 ... completed Suffix Array index\nNov 16 15:19:50 ... writing Genome to disk ...\nNov 16 15:19:50 ... writing Suffix Array to disk ...\nNov 16 15:19:51 ... writing SAindex to disk\nNov 16 15:19:52 ..... finished successfully\n[USERNAME]@bifx-core2:~/course/analysis/01_star_index$ cd ..\n[USERNAME]@bifx-core2:~/course/analysis$ tree\n.\n├── 00_source_data\n│   └── raw_yeast_rnaseq_data.fastq -> ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n└── 01_star_index\n    ├── chrLength.txt\n    ├── chrNameLength.txt\n    ├── chrName.txt\n    ├── chrStart.txt\n    ├── Genome\n    ├── genomeParameters.txt\n    ├── Log.out\n    ├── SA\n    ├── SAindex\n    └── yeast_genome.fasta -> ../../bioinformatics_on_the_command_line_files/yeast_genome.fasta\n\n2 directories, 11 files\n[USERNAME]@bifx-core2:~/course/analysis$ mkdir 02_aligned_reads\n[USERNAME]@bifx-core2:~/course/analysis$ cd 02_aligned_reads\n[USERNAME]@bifx-core2:~/course/analysis/02_aligned_reads$ nice STAR --genomeDir ../01_star_index/ --readFilesIn ../00_source_data/raw_yeast_rnaseq_data.fastq --runThreadN 5 --outFileNamePrefix raw_yeast_rnaseq_data. --outSAMtype BAM SortedByCoordinate\nNov 16 15:22:24 ..... started STAR run\nNov 16 15:22:24 ..... loading genome\nNov 16 15:22:24 ..... started mapping\nNov 16 15:22:26 ..... finished mapping\nNov 16 15:22:27 ..... started sorting BAM\nNov 16 15:22:27 ..... finished successfully\n[USERNAME]@bifx-core2:~/course/analysis/02_aligned_reads$ cd ..\n[USERNAME]@bifx-core2:~/course/analysis$ tree\n.\n├── 00_source_data\n│   └── raw_yeast_rnaseq_data.fastq -> ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n├── 01_star_index\n│   ├── chrLength.txt\n│   ├── chrNameLength.txt\n│   ├── chrName.txt\n│   ├── chrStart.txt\n│   ├── Genome\n│   ├── genomeParameters.txt\n│   ├── Log.out\n│   ├── SA\n│   ├── SAindex\n│   └── yeast_genome.fasta -> ../../bioinformatics_on_the_command_line_files/yeast_genome.fasta\n├── 02_aligned_reads\n│   ├── raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam\n│   ├── raw_yeast_rnaseq_data.Log.final.out\n│   ├── raw_yeast_rnaseq_data.Log.out\n│   ├── raw_yeast_rnaseq_data.Log.progress.out\n│   ├── raw_yeast_rnaseq_data.SJ.out.tab\n│   └── raw_yeast_rnaseq_data._STARtmp\n│       └── BAMsort\n│           ├── 0\n│           ├── 1\n│           ├── 2\n│           ├── 3\n│           └── 4\n├── raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam\n├── raw_yeast_rnaseq_data.Log.out\n├── raw_yeast_rnaseq_data.Log.progress.out\n└── raw_yeast_rnaseq_data._STARtmp\n    └── BAMsort\n\n12 directories, 19 files\n[USERNAME]@bifx-core2:~/course/analysis$ mkdir 03_coverage\n[USERNAME]@bifx-core2:~/course/analysis$ cd 03_coverage\n[USERNAME]@bifx-core2:~/course/analysis/03_coverage$ bedtools genomecov -ibam ../02_aligned_reads/raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam > raw_yeast_rnaseq_data.genomecov.bg\n[USERNAME]@bifx-core2:~/course/analysis/03_coverage$ cd ..\n[USERNAME]@bifx-core2:~/course/analysis$ tree\n.\n├── 00_source_data\n│   └── raw_yeast_rnaseq_data.fastq -> ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n├── 01_star_index\n│   ├── chrLength.txt\n│   ├── chrNameLength.txt\n│   ├── chrName.txt\n│   ├── chrStart.txt\n│   ├── Genome\n│   ├── genomeParameters.txt\n│   ├── Log.out\n│   ├── SA\n│   ├── SAindex\n│   └── yeast_genome.fasta -> ../../bioinformatics_on_the_command_line_files/yeast_genome.fasta\n├── 02_aligned_reads\n│   ├── raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam\n│   ├── raw_yeast_rnaseq_data.Log.final.out\n│   ├── raw_yeast_rnaseq_data.Log.out\n│   ├── raw_yeast_rnaseq_data.Log.progress.out\n│   ├── raw_yeast_rnaseq_data.SJ.out.tab\n│   └── raw_yeast_rnaseq_data._STARtmp\n│       └── BAMsort\n│           ├── 0\n│           ├── 1\n│           ├── 2\n│           ├── 3\n│           └── 4\n└── 03_coverage\n    └── raw_yeast_rnaseq_data.genomecov.bg\n\n11 directories, 17 files\n[USERNAME]@bifx-core2:~/course/analysis$ mkdir 04_gene_overlap_counts\n[USERNAME]@bifx-core2:~/course/analysis$ cd 04_gene_overlap_counts\n[USERNAME]@bifx-core2:~/course/analysis/04_gene_overlap_counts$ ln -s ../../bioinformatics_on_the_command_line_files/yeast_genes.fixed.bed\n[USERNAME]@bifx-core2:~/course/analysis/04_gene_overlap_counts$ bedtools intersect -c -a yeast_genes.fixed.bed -b ../02_aligned_reads/raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam | awk -F'\\t' '$7>0' | sort -k7,7nr > raw_yeast_overlap_data.gene_overlap_counts.bed\n[USERNAME]@bifx-core2:~/course/analysis/04_gene_overlap_counts$ cd ..\n[USERNAME]@bifx-core2:~/course/analysis$ tree\n.\n├── 00_source_data\n│   └── raw_yeast_rnaseq_data.fastq -> ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n├── 01_star_index\n│   ├── chrLength.txt\n│   ├── chrNameLength.txt\n│   ├── chrName.txt\n│   ├── chrStart.txt\n│   ├── Genome\n│   ├── genomeParameters.txt\n│   ├── Log.out\n│   ├── SA\n│   ├── SAindex\n│   └── yeast_genome.fasta -> ../../bioinformatics_on_the_command_line_files/yeast_genome.fasta\n├── 02_aligned_reads\n│   ├── raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam\n│   ├── raw_yeast_rnaseq_data.Log.final.out\n│   ├── raw_yeast_rnaseq_data.Log.out\n│   ├── raw_yeast_rnaseq_data.Log.progress.out\n│   ├── raw_yeast_rnaseq_data.SJ.out.tab\n│   └── raw_yeast_rnaseq_data._STARtmp\n│       └── BAMsort\n│           ├── 0\n│           ├── 1\n│           ├── 2\n│           ├── 3\n│           └── 4\n├── 03_coverage\n│   └── raw_yeast_rnaseq_data.genomecov.bg\n└── 04_gene_overlap_counts\n    ├── raw_yeast_overlap_data.gene_overlap_counts.bed\n    └── yeast_genes.fixed.bed -> ../../bioinformatics_on_the_command_line_files/yeast_genes.fixed.bed\n\n12 directories, 19 files\n[USERNAME]@bifx-core2:~/course/analysis$ head -10 04_gene_overlap_counts/raw_yeast_overlap_data.gene_overlap_counts.bed\nXII 460922  466869  RDN37-2 .   -   3730\nXII 451785  457732  RDN37-1 .   -   3582\nXII 468812  468931  RDN5-2  .   +   3063\nXII 468826  468958  YLR154C-H   .   -   3063\nXII 472464  472583  RDN5-3  .   +   3060\nXII 472478  472610  YLR156C-A   .   -   3060\nXII 482044  482163  RDN5-4  .   +   3055\nXII 482058  482190  YLR157C-C   .   -   3055\nXII 485696  485815  RDN5-5  .   +   3052\nXII 485710  485842  YLR159C-A   .   -   3052\n[USERNAME]@bifx-core2:~/course/analysis$ cd ..\n[USERNAME]@bifx-core2:~/course$ \n\nNote: In this analysis we have done everything from scratch, including creating the genome index. For real analyses on the bifx servers it is a good idea to use a pre-generated index, as indices for larger genomes take up a lot of space on the server. We have also used nice with the STAR command. It is good practice to use nice with programs such as aligners that could run for a long time and take a lot of resources. nice tells Linux to run the STAR command with low priority so that it doesn’t slow down the server for other users.\n\n\n\n Challenge:\n\nWe saw earlier that the longest gene on chromosome I is YAR050W. Use bedtools getfasta to find the nucleotide sequence of this gene in FASTA format.\n\n\n\n\nSolution. \n\n Solution:\n\nRunning bedtools getfasta --help shows us that we need to specify and input DNA FASTA file and a BED file with the feature co-ordinates.  We can extract the feature co-ordinates of YAR050W from yeast_genes.fixed.bed using awk, and use the output of this command with bedtools getfasta. This is illustrated in the following example:\n\n[USERNAME]@bifx-core2:~/course$ bedtools getfasta -fi yeast_genome.fasta -bed <(awk -F'\\t' '$4==\"YAR050W\"' yeast_genes.fixed.bed)\n>I:203402-208016\nATGACAATGCCTCATCGCTATATGTTTTTGGCAGTCTTTACACTTCTGGCACTAACTAGTGTGGCCTCAGGAGCCACAGAGGCGTGCTTACCAGCAGGCCAGAGGAAAAGTGGGATGAATATAAATTTTTACCAGTATTCATTGAAAGATTCCTCCACATATTCGAATGCAGCATATATGGCTTATGGATATGCCTCAAAAACCAAACTAGGTTCTGTCGGAGGACAAACTGATATCTCGATTGATTATAATATTCCCTGTGTTAGTTCATCAGGCACATTTCCTTGTCCTCAAGAAGATTCCTATGGAAACTGGGGATGCAAAGGAATGGGTGCTTGTTCTAATAGTCAAGGAATTGCATACTGGAGTACTGATTTATTTGGTTTCTATACTACCCCAACAAACGTAACCCTAGAAATGACAGGTTATTTTTTACCACCACAGACGGGTTCTTACACATTCAAGTTTGCTACAGTTGACGACTCTGCAATTCTATCAGTAGGTGGTGCAACCGCGTTCAACTGTTGTGCTCAACAGCAACCGCCGATCACATCAACGAACTTTACCATTGACGGTATCAAGCCATGGGGTGGAAGTTTGCCACCTAATATCGAAGGAACCGTCTATATGTACGCTGGCTACTATTATCCAATGAAGGTTGTTTACTCGAACGCTGTTTCTTGGGGTACACTTCCAATTAGTGTGACACTTCCAGATGGTACCACTGTAAGTGATGACTTCGAAGGGTACGTCTATTCCTTTGACGATGACCTAAGTCAATCTAACTGTACTGTCCCTGACCCTTCAAATTATGCTGTCAGTACCACTACAACTACAACGGAACCATGGACCGGTACTTTCACTTCTACATCTACTGAAATGACCACCGTCACCGGTACCAACGGCGTTCCAACTGACGAAACCGTCATTGTCATCAGAACTCCAACAACTGCTAGCACCATCATAACTACAACTGAGCCATGGAACAGCACTTTTACCTCTACTTCTACCGAATTGACCACAGTCACTGGCACCAATGGTGTACGAACTGACGAAACCATCATTGTAATCAGAACACCAACAACAGCCACTACTGCCATAACTACAACTGAGCCATGGAACAGCACTTTTACCTCTACTTCTACCGAATTGACCACAGTCACCGGTACCAATGGTTTGCCAACTGATGAGACCATCATTGTCATCAGAACACCAACAACAGCCACTACTGCCATGACTACAACTCAGCCATGGAACGACACTTTTACCTCTACTTCTACCGAATTGACCACAGTCACCGGTACCAATGGTTTGCCAACTGATGAGACCATCATTGTCATCAGAACACCAACAACAGCCACTACTGCCATGACTACAACTCAGCCATGGAACGACACTTTTACCTCTACTTCTACCGAATTGACCACAGTCACCGGTACCAATGGTTTGCCAACTGATGAGACCATCATTGTCATCAGAACACCAACAACAGCCACTACTGCCATGACTACAACTCAGCCATGGAACGACACTTTTACCTCTACATCCACTGAAATCACCACCGTCACCGGTACCAATGGTTTGCCAACTGATGAGACCATCATTGTCATCAGAACACCAACAACAGCCACTACTGCCATGACTACACCTCAGCCATGGAACGACACTTTTACCTCTACATCCACTGAAATGACCACCGTCACCGGTACCAACGGTTTGCCAACTGATGAAACCATCATTGTCATCAGAACACCAACAACAGCCACTACTGCCATAACTACAACTGAGCCATGGAACAGCACTTTTACCTCTACATCCACTGAAATGACCACCGTCACCGGTACCAACGGTTTGCCAACTGATGAAACCATCATTGTCATCAGAACACCAACAACAGCCACTACTGCCATAACTACAACTCAGCCATGGAACGACACTTTTACCTCTACATCCACTGAAATGACCACCGTCACCGGTACCAACGGTTTGCCAACTGATGAAACCATCATTGTCATCAGAACACCAACAACAGCCACTACTGCCATGACTACAACTCAGCCATGGAACGACACTTTTACCTCTACATCCACTGAAATCACCACCGTCACCGGTACCACCGGTTTGCCAACTGATGAGACCATCATTGTCATCAGAACACCAACAACAGCCACTACTGCCATGACTACAACTCAGCCATGGAACGACACTTTTACCTCTACATCCACTGAAATGACCACCGTCACCGGTACCAACGGCGTTCCAACTGACGAAACCGTCATTGTCATCAGAACTCCAACTAGTGAAGGTCTAATCAGCACCACCACTGAACCATGGACTGGTACTTTCACCTCTACATCCACTGAGATGACCACCGTCACCGGTACTAACGGTCAACCAACTGACGAAACCGTGATTGTTATCAGAACTCCAACCAGTGAAGGTTTGGTTACAACCACCACTGAACCATGGACTGGTACTTTTACTTCTACATCTACTGAAATGACCACCATTACTGGAACCAACGGCGTTCCAACTGACGAAACCGTCATTGTCATCAGAACTCCAACCAGTGAAGGTCTAATCAGCACCACCACTGAACCATGGACTGGTACTTTTACTTCTACATCTACTGAAATGACCACCATTACTGGAACCAATGGTCAACCAACTGACGAAACCGTTATTGTTATCAGAACTCCAACTAGTGAAGGTCTAATCAGCACTACAACGGAACCATGGACCGGTACTTTCACTTCTACATCTACTGAAATGACGCACGTCACCGGTACCAACGGCGTTCCAACTGACGAAACCGTCATTGTCATCAGAACTCCAACCAGTGAAGGTCTAATCAGCACCACCACTGAACCATGGACTGGCACTTTCACTTCGACTTCCACTGAGGTTACCACCATCACTGGAACCAACGGTCAACCAACTGACGAAACTGTGATTGTTATCAGAACTCCAACCAGTGAAGGTCTAATCAGCACCACCACTGAACCATGGACTGGTACTTTCACTTCTACATCTACTGAAATGACCACCGTCACCGGTACTAACGGTCAACCAACTGACGAAACCGTGATTGTTATCAGAACTCCAACCAGTGAAGGTTTGGTTACAACCACCACTGAACCATGGACTGGTACTTTTACTTCGACTTCCACTGAAATGTCTACTGTCACTGGAACCAATGGCTTGCCAACTGATGAAACTGTCATTGTTGTCAAAACTCCAACTACTGCCATCTCATCCAGTTTGTCATCATCATCTTCAGGACAAATCACCAGCTCTATCACGTCTTCGCGTCCAATTATTACCCCATTCTATCCTAGCAATGGAACTTCTGTGATTTCTTCCTCAGTAATTTCTTCCTCAGTCACTTCTTCTCTATTCACTTCTTCTCCAGTCATTTCTTCCTCAGTCATTTCTTCTTCTACAACAACCTCCACTTCTATATTTTCTGAATCATCTAAATCATCCGTCATTCCAACCAGTAGTTCCACCTCTGGTTCTTCTGAGAGCGAAACGAGTTCAGCTGGTTCTGTCTCTTCTTCCTCTTTTATCTCTTCTGAATCATCAAAATCTCCTACATATTCTTCTTCATCATTACCACTTGTTACCAGTGCGACAACAAGCCAGGAAACTGCTTCTTCATTACCACCTGCTACCACTACAAAAACGAGCGAACAAACCACTTTGGTTACCGTGACATCCTGCGAGTCTCATGTGTGCACTGAATCCATCTCCCCTGCGATTGTTTCCACAGCTACTGTTACTGTTAGCGGCGTCACAACAGAGTATACCACATGGTGCCCTATTTCTACTACAGAGACAACAAAGCAAACCAAAGGGACAACAGAGCAAACCACAGAAACAACAAAACAAACCACGGTAGTTACAATTTCTTCTTGTGAATCTGACGTATGCTCTAAGACTGCTTCTCCAGCCATTGTATCTACAAGCACTGCTACTATTAACGGCGTTACTACAGAATACACAACATGGTGTCCTATTTCCACCACAGAATCGAGGCAACAAACAACGCTAGTTACTGTTACTTCCTGCGAATCTGGTGTGTGTTCCGAAACTGCTTCACCTGCCATTGTTTCGACGGCCACGGCTACTGTGAATGATGTTGTTACGGTCTATCCTACATGGAGGCCACAGACTGCGAATGAAGAGTCTGTCAGCTCTAAAATGAACAGTGCTACCGGTGAGACAACAACCAATACTTTAGCTGCTGAAACGACTACCAATACTGTAGCTGCTGAGACGATTACCAATACTGGAGCTGCTGAGACGAAAACAGTAGTCACCTCTTCGCTTTCAAGATCTAATCACGCTGAAACACAGACGGCTTCCGCGACCGATGTGATTGGTCACAGCAGTAGTGTTGTTTCTGTATCCGAAACTGGCAACACCAAGAGTCTAACAAGTTCCGGGTTGAGTACTATGTCGCAACAGCCTCGTAGCACACCAGCAAGCAGCATGGTAGGATATAGTACAGCTTCTTTAGAAATTTCAACGTATGCTGGCAGTGCCAACAGCTTACTGGCCGGTAGTGGTTTAAGTGTCTTCATTGCGTCCTTATTGCTGGCAATTATTTAA\n[USERNAME]@bifx-core2:~/course$ \n\n\n\n\n\n\n\n Challenge:\n\nHow could you use bedtools genomecov to make separate bedGraph files for the plus and minus strands?\n\n\n\n\nSolution. \n\n Solution:\n\nRunning bedtools genomecov --help shows us that there is a -strand option.  To make a bedGraph file for the plus strand, run bedtools genomecov -strand + -ibam 02_aligned_reads/raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam  To make a bedGraph file for the minus strand, run bedtools genomecov -strand - -ibam 02_aligned_reads/raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam"
  },
  {
    "objectID": "00-start.html",
    "href": "00-start.html",
    "title": "Getting Started",
    "section": "",
    "text": "We recommend using RStudio for this workshop. RStudio is an Integrated Development Environment (IDE) for R. It can be accessed in several ways. Download RStudio and install it on your own computer."
  },
  {
    "objectID": "00-start.html#using-rstudio",
    "href": "00-start.html#using-rstudio",
    "title": "Getting Started",
    "section": "Using RStudio",
    "text": "Using RStudio\n\n\n\nThe are 4 main panes, each with several tabs:\n\nConsole (bottom left)\n\nHere you can type commands into R\nAdditional tabs may include a terminal and script outputs\n\nEditor (top left)\n\nOpen and view files\nThese can be raw txt, scripts or markdown\n\nEnvironment (top right)\n\nObjects you have stored\nCommands you have typed\nAdditional tabs for version control, database and website building…\n\nFiles and output (bottom right)\n\nSystem files (on the computer/server you are working on)\nOutput from plots or applications\nPackages available\nHelp pages\n\n\n\n\n\n\n\nYou can cutomise the appearance of RStudion under the Tools -> Global Options… menu.\n\n\nSetting up a new project\nThere is a drop-down project menu at the top right of RStudio. Click this, select “New Project…” and create one in a new directory. Make sure you have write permission for the directory you choose.\nOnce you have done this, this will be your working directory. Files will be saved (or loaded from) here by default unless you specify a full path. You can change your working directory under the session menu at the top.\nUsing Rstudio has the advantage that everything you do can be saved between RStudio sessions."
  },
  {
    "objectID": "00-start.html#running-commands",
    "href": "00-start.html#running-commands",
    "title": "Getting Started",
    "section": "Running commands",
    "text": "Running commands\n\nYou can work in 3 different ways in RStudio.\n\nUse the console to run commands.\nCreate a new R script to save your commands as you go.\nCreate an R markdown file to generate web pages or pdf documents from your analyses.\n\nCommands can be typed directly into the console, but in order to keep track it’s best to write them into a script as you go (File->New File->R Script). From here you can use a shortcut to run the command on the line where your cursor is:\n\nAlt + Enter to keep the cursor on the same line\nCtrl + Enter to move to the next line\n\nYou can also use the Tab key to autocomplete names of functions and objects as you type them into your script.\nHint: When using the console, the Up/Down arrow keys can be use to cycle through previous commands.\nIn the console you should always see a > prompt, if you can’t see this R may still be working. There is a red Stop light at the top right of the console when a command is running. If you see a + instead of >, R is waiting for more input. Sometimes this means you have forgotten to close a bracket or quotation.\nUsing R Markdown is a great way to annotate your code and present it at the end. It’s worth learning but will add a further level of complication for novice users."
  },
  {
    "objectID": "00-start.html#installing-libraries",
    "href": "00-start.html#installing-libraries",
    "title": "Getting Started",
    "section": "Installing libraries",
    "text": "Installing libraries\n\nLibraries provide additional functions in R and can be downloaded from several sources:\n\nCRAN is the Comprehensive R Archive Network and hosts the majority of generic R packages.\nBioconductor is a repository of biology specific packages.\nThird party tools are often hosted on github.\n\nInstall the packages we need for these lesssons by running the code below in the R console:\n\n#install from CRAN with install.packages()\ninstall.packages(c(\"ggplot2\", \"ggthemes\", \"plotly\",\"ggpubr\", \"ggrepel\",\"viridis\",\"RColorBrewer\",\"ggsci\",\"tidyverse\"))\n\n#install from bioconductor with BiocManager\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\nBiocManager::install(c(\"DESeq2\",\"genomation\"))\n\n#install from github with the devtools package\ninstall.packages(\"devtools\")\ndevtools::install_github(\"thomasp85/patchwork\")\n\nTo load a specific package within an R session, use the “library” function:\n\nlibrary(tidyverse)\n\n\n\n\n How to follow this tutorial\n\n\n\n\nCreate a new project in RStudio\nInstall the required libraries\nOpen a new R script (or R markdown file for advanced users)\nIt will be best to work with the tutorial and RStudio open together so you can easily switch between the two. Working on a wide split-screen or multiple desktops is the best setup.\nI recommend typing out commands rather than copy-and-pasting if you want to learn. Remember you can use the Tab key to save on typing!"
  },
  {
    "objectID": "00-start.html#section",
    "href": "00-start.html#section",
    "title": "Getting Started",
    "section": "",
    "text": "Create a new project in RStudio\nInstall the required libraries\nOpen a new R script (or R markdown file for advanced users)\nIt will be best to work with the tutorial and RStudio open together so you can easily switch between the two. Working on a wide split-screen or multiple desktops is the best setup.\nI recommend typing out commands rather than copy-and-pasting if you want to learn. Remember you can use the Tab key to save on typing!"
  },
  {
    "objectID": "01-start.html",
    "href": "01-start.html",
    "title": "Getting Started",
    "section": "",
    "text": "In this section you will learn how to log into the WCB’s bifx servers, and run some simple commands. You will also learn how to find out about commands, and how to use bash efficiently.\n\n\nStarting a Terminal and logging in to the remote server\n\nThe process of starting a terminal depends on the operating system that you are using:\n\nOn Mac OS X or Ubuntu Linux, simply open the ‘Terminal’ application\nOn Windows, you can install MobaXTerm\n\nIn order to log in to the bifx-core2 server, you must first connect to the Edinburgh University VPN.\nOnce logged in to the VPN, you can log in to the server by typing the following command in the Terminal, substituting [USERNAME] for your account username:\n\n$ ssh [USERNAME]@bifx-core2.bio.ed.ac.uk\n\nIf you are using MobaXTerm, an alternative way of logging in to the server is shown in the MobaXTerm demo.\nOnce you have typed in your password, you should see some welcome text and a prompt that looks something like this:\n\n[USERNAME]@bifx-core2:~$\n\nThis prompt shows you that you are logged in to the bifx-core2 server, and that you are in your home directory (which is referred to using the ~ character on Linux systems).\nNote: If you find that your connection to the server keeps dropping out, you can use a tool such as tmux or screen to create a persistent session.\n\n\n\nRunning basic commands in bash\n\n\n\n\n Key Points\n\n\nCommands in bash can be categorised as either:\n\nbuilt in commands (or builtins), which are part of the bash shell, or\ninstalled programs, which could be either the basic GNU core utilities (or coreutils), included in most Linux distributions, or other programs, such as specialised bioinformatics tools\n\n\n\n\nIn order to run a command in bash you type the command and then press the return key to execute it. For example, try typing date at the prompt and pressing return. You should get something like this:\n\n[USERNAME]@bifx-core2:~$ date\nMon 16 Nov 09:21:43 GMT 2020\n[USERNAME]@bifx-core2:~$ \n\nAs you can see, the output of the date command is printed on the command line, and then another prompt is shown.\nAs well as the command name, a command can include ‘options’ and ‘arguments’. For example, try typing date -d '25 Dec' +%j at the command line:\n\n[USERNAME]@bifx-core2:~$ date -d '25 Dec' +%j\n360\n[USERNAME]@bifx-core2:~$ \n\nIn this example, the command includes the following elements:\n\nthe command name date, which always comes first\none option -d '25 Dec', which has a name -d (option names always start with at least one ‘-’), and a value '25 Dec'\none argument +%j\n\n\n\nOptions and arguments\nOptions always have a name, but do not always need to have an associated value. Options that don’t have a value are called flags, and are often used as switches for different kinds of functionality. Unlike options, arguments don’t have names. Instead they are identified by their position.\nIn general, the values of options and arguments are text strings, which are passed directly to the command. If a value contains spaces, you can surround it with quote marks, as in the example above, so that it is recognised as a single value. You can also use the output of one command as an argument to another by enclosing it in backticks ```, as in the following example:\n\n[USERNAME]@bifx-core2:~$ echo date\ndate\n[USERNAME]@bifx-core2:~$ echo `date`\nSat 14 Nov 11:25:11 GMT 2020\n[USERNAME]@bifx-core2:~$ \n\nNote: The above example uses the echo command, which outputs the values of its arguments.\n\n\n\n\nFinding out about bash commands\n\n\n\n Key Points\n\n\nThe bash shell provides a number of different ways to access information about commands, in particular:\n\nThe man command\nThe info command\n--help and -h flags\n\n\n\nWhile the use of options and arguments makes commands more powerful and flexible, they can be difficult to remember, and can vary between different versions of the command. For this reason, it is useful to be able to find information about commands easily.\n\n\nThe man command\nThis displays a short manual page for a single command. To see the manual page for the date command simply type man date.\n\nYou can scroll through the man page using space, and type q to quit\n\nYou can learn more about different commands by typing h\n\nTo learn about bash builtins, type man builtins\n\n\n\n\nThe info command\nThis displays a more comprehensive hyperlinked manual, which provides detailed information about the GNU coreutils. Simply type info to see the info documentation, and type H in info to find out how to navigate the documentation. Press q to quit.\n\n\n\n--help and -h flags\nSome programs may not have any documentation that is accessible using the man or info commands. In this case, they may follow the convention of including --help or -h flags, which will show some usage information. As an example, we can try to find help information about bedtools, which is a well known bioinformatics tool that we will look at later in the course:\n\n[USERNAME]@bifx-core2:~$ man bedtools\nNo manual entry for bedtools\nSee 'man 7 undocumented' for help when manual pages are not available.\n[USERNAME]@bifx-core2:~$ info bedtools\ninfo: No menu item 'bedtools' in node '(dir)Top'\n[USERNAME]@bifx-core2:~$ bedtools --help\nbedtools is a powerful toolset for genome arithmetic.\n\nVersion:   v2.27.0\n...\n\n\n\n\n Challenge:\n\nWe saw the command “date -d ‘25 Dec’ +%j” in the previous section. Can you use the man command to explain what it does?\n\n\n\n\nSolution. \n\n Solution:\n\nRun man date, and look for the -d flag. The documentation explains that -d tells date to display the time described by the value of the option, rather than the current time. Now look up %j in the documentation. The relevant line says ‘%j day of year (001..366)’. So the command tells you which day of the year it will be on the 25th of December.\n\n\n\n\n\n\n\nUsing bash efficiently\n\n\n\n\n Key Points\n\n\nWorking with long commands in bash can be laborious, but luckily there are a few tricks that you can use to make things easier. These are:\n\nKeyboard shortcuts\nTab completion\nUsing the bash history\n\n\n\n\n\nKeyboard shortcuts\nBy default, bash allows you to use many keyboard shortcuts from the GNU Emacs editor to work with your commands. These include:\n\nCtrl+a to move to the beginning of the line\nCtrl+e to move to the end of the line\nCtrl/Meta+f to move forward one character (Ctrl+f) or one word (Meta+f)\n\nThe Meta key is generally the Alt key, or the option key on a Mac\nIf the option key doesn’t work as Meta on a Mac and you’re using the Terminal application, ensure that the Use Option as Meta key checkbox is ticked for your selected profile (this can be found under Preferences > Profiles > Keyboard)\n\nCtrl/Meta+b to move back one character (Ctrl+b) or one word (Meta+b)\nCtrl+k to cut the text from the cursor to the end of the line\nCtrl+y to paste text at the cursor\n\nYou can also use Ctrl+c to terminate the command that is currently running and take you back to the command prompt.\n\n\n\nTab completion\nTab completion allows you to type part of a command name followed by the Tab key, which prompts bash to guess the rest of the command name based on the commands that are available on the system.\nFor instance, if you want to run the bedtools command on the server, you can type bedt followed by Tab, and the rest of the command name will be filled in for you.\nTyping Tab once to complete a command name only works if there is only one possible way to complete the name. If there are multiple options and you would like to see them, you can type Tab twice, and the possible completions will be displayed.\n\n\n\nUsing the bash history\nA particularly useful feature of command line shells is the ability to look back at previous commands that you have run. In bash you can access these commands using the history command. Typing history will show you a numbered list of commands you’ve run recently. You can also specify the number of previous commands you’d like to see by including it as an argument.\nThere are a few useful tricks that make it easy to find and run commands that you have run before:\n\nScrolling through the history with the up and down arrows (or Ctrl+p and Ctrl+n)\nSearching the history with Ctrl+r (reverse-i-search)\nRe-running a previously run command with ! followed by the number of the command\n\n\n\n\n Challenge:\n\nWhat are the possible completions of ‘bed’ on the server?\n\n\n\n\nSolution. \n\n Solution:\n\nAdd the command prompt type bed then press Tab twice. You should see the following:\n\n[USERNAME]@bifx-core2:~$ bed<Tab><Tab>\nbed12ToBed6                   bedExons.pl                   bedRestrictToPositions\nbed2gff3.pl                   bed_extend_to.py              bedSort\nbed2pos.pl                    bedextract                    bedSpliceSite.pl\nbed2region                    bedGeneParts                  bedSplitOnChrom\nbed2tag.pl                    bedGraphToBigWig              bed_subtract_basewise.py\nbed_bigwig_profile.py         bedInGraph                    bedToBam\nbed_build_windows.py          bedIntersect                  bedToBigBed\nbedClip                       bed_intersect_basewise.py     bedToExons\nbedCombiner.pl                bed_intersect.py              bedToFrames\nbedCommonRegions              bedItemOverlapCount           bedToGenePred\nbed_complement.py             bedLengthFilter.pl            bedToIgv\nbedCons                       bedmap                        bed_to_juncs\nbed_count_by_interval.py      bed_merge_overlapping.py      bedtools\nbed_count_overlapping.py      bedops                        bedToPsl\nbedCoverage                   bedops-starch                 bedToTxEdges\nbed_coverage_by_interval.py   bedOrBlocks                   bedUp\nbed_coverage.py               bedpeToBam                    bedWeedOverlapping\nbed_diff_basewise_summary.py  bed_rand_intersect.py\nbedDown                       bedRemoveOverlap\n[USERNAME]@bifx-core2:~$\n\n\n\n\n\n\n\n Challenge:\n\nUse the history to re-run the date -d '25 Dec' +%j command without re-typing it\n\n\nSolution\n\n\nSolution. \n\n Solution:\n\nThere are three ways to do this:  One way would be to press Ctrl+r, then type date, then press Ctrl+r again repeatedly until you see the command, then press Enter to run it.  Alternatively, you could run the history command and look back through the history list to find the command. Then you could type ! at the command prompt followed by the number of the command in the history.  A third way would be to either hit the up arrow or type Ctrl+p to scroll back through the history until you see the command, then press Enter to run it."
  },
  {
    "objectID": "03-files.html",
    "href": "03-files.html",
    "title": "Working with files",
    "section": "",
    "text": "In this section you will learn how to explore and manipulate files in bash using simple commands, and compound commands using pipes.\n\n\nExploring files\n\n\n\n\n Key Points\n\n\nRegular files in Linux can be classified as text files, which contain human readable text, and binary files, that contain data that is not human readable\nThe cat command can be used to show the contents of a file\n\nThe less command allows you to page through a large file as if it were a man page\n\nThe head and tail commands can be used to show the first or last few lines of a file\n\nThese can be useful for large text files\n\nThe wc -l command counts the number of lines in a file\nThe grep command allows you to filter a text file\nText files can be compressed using the gzip command, which converts them to a binary format that takes up less space\n\nMany of the above commands for working with text files have equivalents for gzipped files\nThese include zcat, zless, and zgrep\n\n\n\n\nThe following example demonstrates how we can explore text files:\n\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── bioinformatics_on_the_command_line_files\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── README\n│   ├── yeast_genes.bed\n│   └── yeast_genome.fasta\n└── bioinformatics_on_the_command_line_files.tar.gz\n\n1 directory, 5 files\n[USERNAME]@bifx-core2:~/course$ cat bioinformatics_on_the_command_line_files/README\nThis archive contains reference files for the 'Introduction to Bioinformatics on the Command Line' course. In the course you will learn how to build a simple pipeline to analyse some yeast RNA-Seq data using these files. The following files are included:\n\n- raw_yeast_rnaseq_data.fastq: This is a file containing 10,000 raw reads taken from a yeast RNA-Seq experiment\n- yeast_genome.fasta: This file contains the reference genome sequence for yeast (EF4) in fasta format\n- yeast_genes.bed: This file contains the genomic co-ordinates of yeast genes in bed format\n[USERNAME]@bifx-core2:~/course$ less bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n...\n<q>\n[USERNAME]@bifx-core2:~/course$ head -5 bioinformatics_on_the_command_line_files/yeast_genome.fasta\n>I\nCCACACCACACCCACACACCCACACACCACACCACACACCACACCACACCCACACACACA\nCATCCTAACACTACCCTAACACAGCCCTAATCTAACCCTGGCCAACCTGTCTCTCAACTT\nACCCTCCATTACCCTGCCTCCACTCGTTACCCTGTCCCATTCAACCATACCACTCCGAAC\nCACCATCCATCCCTCTACTTACTACCACTCACCCACCGTTACCCTCCAATTACCCATATC\n[USERNAME]@bifx-core2:~/course$ tail -5 bioinformatics_on_the_command_line_files/yeast_genome.fasta\nGTGTTTGTTGCACGGCAGTAGCGAGAGACAAGTGGGAAAGAGTAGGATAAAAAGACAATC\nTATAAAAAGTAAACATAAAATAAAGGTAGTAAGTAGCTTTTGGTTGAACATCCGGGTAAG\nAGACAACAGGGCTTGGAGGAGACGTACATGAGGGCTATTTAGGGCTATTTAGGGCTATGT\nAGAAGTGTTGTAGGGCTAAAGAACAGGGTTTCATTTTCATTTTTTTTTTTTAATTTCGGT\nCAGAAA\n[USERNAME]@bifx-core2:~/course$ wc -l bioinformatics_on_the_command_line_files/yeast_genes.bed\n7126 bioinformatics_on_the_command_line_files/yeast_genes.bed\n[USERNAME]@bifx-core2:~/course$ grep format bioinformatics_on_the_command_line_files/README\nThis archive contains reference files for the 'Introduction to Bioinformatics on the Command Line' course. In the course you will learn how to build a simple pipeline to analyse some yeast RNA-Seq data using these files. The following files are included:\n- yeast_genome.fasta: This file contains the reference genome sequence for yeast (EF4) in fasta format\n- yeast_genes.bed: This file contains the genomic co-ordinates of yeast genes in bed format\n[USERNAME]@bifx-core2:~/course$ grep -v format bioinformatics_on_the_command_line_files/README\n\n- raw_yeast_rnaseq_data.fastq: This is a file containing 10,000 raw reads taken from a yeast RNA-Seq experiment\n[USERNAME]@bifx-core2:~/course$ grep -c -E '^>' bioinformatics_on_the_command_line_files/yeast_genome.fasta\n17\n[USERNAME]@bifx-core2:~/course$ gzip -k bioinformatics_on_the_command_line_files/yeast_genome.fasta\n[USERNAME]@bifx-core2:~/course$ ls -lh bioinformatics_on_the_command_line_files/yeast_genome.fasta*\n-rw-rw-r-- 1 [USERNAME] [USERNAME]  12M Nov 12 12:38 bioinformatics_on_the_command_line_files/yeast_genome.fasta\n-rw-rw-r-- 1 [USERNAME] [USERNAME] 3.7M Nov 12 12:38 bioinformatics_on_the_command_line_files/yeast_genome.fasta.gz\n[USERNAME]@bifx-core2:~/course$ zgrep -c -E '^>' bioinformatics_on_the_command_line_files/yeast_genome.fasta.gz\n17\n[USERNAME]@bifx-core2:~/course$\n\nNote: The -E flag in grep allows you to use a regular expression to specify a pattern that grep will look for rather than a fixed string. Conceptually, regular expressions are similar to glob patterns, although their syntax is different. Some characters have a special meaning in regular expressions. For example:\n\n^ represents the start of a string\n$ represents the end of a string\n.* represents a sequence of zero or more characters\n.+ represents a sequence of one or more characters\n\n\n\n\n Challenge:\n\nHow would you check that every line of the ‘yeast_genes.bed’ file starts with the string ‘chr’ without looking through the whole file?\n\n\n\n\nSolution. \n\n Solution:\n\nRun grep -v -c -E '^chr' bioinformatics_on_the_command_line_files/yeast_genes.bed to count the number of lines that don’t start with ‘chr’. We can see that this is zero, so every line must start with ‘chr’.\n\n\n\n\n\n\nShell redirection\n\n\n\n\n Key Points\n\n\nThe shell can manage where programs receive inputs from and where they send outputs to\nIt provides three I/O channels for programs to use. These are:\n\nStandard input, or STDIN, which provides input to the program\nStandard output, or STDOUT, which receives output from the program\nStandard error, or STDERR, which receives error messages from the program\n\nProgram authors don’t have to use these I/O channels, but most command line tools designed for Linux, such as the GNU coreutils, do use them\nBy default, STDIN comes from the keyboard, and STDOUT and STDERR go to the terminal, but each of these channels can be redirected\n\n> redirects STDOUT to an output file, overwriting its contents\n>> redirects STDOUT to an output file, appending to its contents\n2> redirects STDERR to an output file, overwriting its contents\n2>> redirects STDERR to an output file, appending to its contents\n< reads each line from an input file and feeds it to STDIN\n2>&1 redirects STDERR to STDOUT\n\n\n\n\nThe following example demonstrates how shell redirection works:\n\n[USERNAME]@bifx-core2:~/course$ echo zero > output.txt\n[USERNAME]@bifx-core2:~/course$ cat < output.txt\nzero\n[USERNAME]@bifx-core2:~/course$ echo one > output.txt\n[USERNAME]@bifx-core2:~/course$ cat < output.txt\none\n[USERNAME]@bifx-core2:~/course$ echo two >> output.txt\n[USERNAME]@bifx-core2:~/course$ cat < output.txt\none\ntwo\n[USERNAME]@bifx-core2:~/course$ cat bioinformatics_on_the_command_line_files/README > cat_readme.out 2> cat_readme.err\n[USERNAME]@bifx-core2:~/course$ head -2 cat_readme.*\n==> cat_readme.err <==\n\n==> cat_readme.out <==\nThis archive contains reference files for the 'Introduction to Bioinformatics on the Command Line' course. In the course you will learn how to build a simple pipeline to analyse some yeast RNA-Seq data using these files. The following files are included:\n\n[USERNAME]@bifx-core2:~/course$ zcat bioinformatics_on_the_command_line_files/README > zcat_readme.out 2> zcat_readme.err\n[USERNAME]@bifx-core2:~/course$ head -2 zcat_readme.*\n==> zcat_readme.err <==\n\ngzip: bioinformatics_on_the_command_line_files/README: not in gzip format\n\n==> zcat_readme.out <==\n[USERNAME]@bifx-core2:~/course$ zcat bioinformatics_on_the_command_line_files/README > zcat_readme.all 2>&1\n[USERNAME]@bifx-core2:~/course$ cat zcat_readme.all\n\ngzip: bioinformatics_on_the_command_line_files/README: not in gzip format\n[USERNAME]@bifx-core2:~/course$ rm -i *cat_readme.* output.txt\nrm: remove regular empty file 'cat_readme.err'? y\nrm: remove regular file 'cat_readme.out'? y\nrm: remove regular file 'zcat_readme.all'? y\nrm: remove regular file 'zcat_readme.err'? y\nrm: remove regular empty file 'zcat_readme.out'? y\nrm: remove regular file 'output.txt'? y\n[USERNAME]@bifx-core2:~/course$ \n\n\n\n\n Challenge:\n\ncat output.txt and cat < output.txt do the same thing, but echo output.txt and echo < output.txt don’t. Why?\n\n\n\n\nSolution. \n\n Solution:\n\nThe cat command opens the file given as an argument and processes the lines one by one, and it treats lines received from STDIN in the same way. Many programs work this way, but some, like echo don’t. echo simply ignores what comes in from STDIN.\n\n\n\n\n\n\nCreating compound commands using pipes\n\n\n\n\n Key Points\n\n\nBecause the shell provides standard input and output channels, it is possible to chain together simple commands to perform complex tasks\nThis can be done using a ‘pipe’, represented by the pipe character |\n\n\n\nSo far we have discussed simple commands, which consist of a single command name followed by some options and arguments. However, a lot of the flexibility of the tools accessible via bash comes from the ability to combine them to form compound commands, using pipes. This allows the user to perform complex tasks by joining together simple commands.\nMotivating example: How do you count how many of the first 40 lines in a FASTQ file contain the sequence ACTG?\nHere’s how you could do it using simple commands:\n\n[USERNAME]@bifx-core2:~/course$ head -40 bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq > first_40_lines.tmp\n[USERNAME]@bifx-core2:~/course$ grep -c ACTG first_40_lines.tmp\n5\n[USERNAME]@bifx-core2:~/course$ rm -i first_40_lines.tmp\nrm: remove regular file 'first_40_lines.tmp'? y\n[USERNAME]@bifx-core2:~/course$ \n\nHere’s how you can do it in a single command using a pipe:\n\n[USERNAME]@bifx-core2:~/course$ head -40 bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq | grep -c ACTG\n5\n[USERNAME]@bifx-core2:~/course$ \n\nPipes are particularly useful for working with large files, as they remove the need to create large intermediate files, which may take up space. They can also save time, as commands can sometimes start working on the data produced by commands preceding them in the pipeline before they have finished running, and in some cases preceding commands can be terminated early if further outputs are no longer needed.\nBecause some programs only operate on files and do not accept input from STDIN, it is sometimes useful to present the output of one program to another program as if it were a file. This can be done using the <() notation. For example, the command shown above could also be written using this notation as follows:\n\n[USERNAME]@bifx-core2:~/course$ grep -c ACTG <(head -40 bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq)\n5\n[USERNAME]@bifx-core2:~/course$ \n\n\n\n\n Challenge\n\nWe can find how long it takes to find the first line in ‘/homes/genomes/mouse/UCSC/mm10/Sequence/WholeGenomeFasta/genome.fa’ that countains the character ‘A’ by writing all matches to a temporary file and then finding the first line using head as follows:\n\n[USERNAME]@bifx-core2:~/course$ time grep A /homes/genomes/mouse/UCSC/mm10/Sequence/WholeGenomeFasta/genome.fa > grepA.tmp\n\nreal    0m36.182s\nuser    0m7.831s\nsys     0m6.377s\n[USERNAME]@bifx-core2:~/course$ time head -1 grepA.tmp\ngcttcagaataatcatattattctcaaattttgtatcaatataaaaaaaA\n\nreal    0m0.008s\nuser    0m0.001s\nsys     0m0.003s\n[USERNAME]@bifx-core2:~/course$ rm -ri grepA.tmp\nrm: remove regular file 'grepA.tmp'? y\n[USERNAME]@bifx-core2:~/course$ \n\nWe can see that the operation takes just over 36 seconds. Using the time command, find the length of time it takes to perform the same task using a pipe. Is there much of a difference? Why?\n\n\n\n\nSolution. \n\n Solution:\n\nTo find out how long it takes to find the line with a pipe you can do the following:\n\n[USERNAME]@bifx-core2:~/course$ time grep A /homes/genomes/mouse/UCSC/mm10/Sequence/WholeGenomeFasta/genome.fa | head -1\ngcttcagaataatcatattattctcaaattttgtatcaatataaaaaaaA\n\nreal    0m0.011s\nuser    0m0.002s\nsys 0m0.012s\n\nAs we can see the operation completes in about 0.01 seconds, so using a pipe is considerably faster. This is because the pipeline stops when it has found the first match, so the grep command doesn’t have to go through the whole file.\nNote: it is actually possible to find the first match quickly using a single grep command and no pipe, by using the -m option in grep."
  },
  {
    "objectID": "06-scripts.html",
    "href": "06-scripts.html",
    "title": "Scripting for reproducible data analysis",
    "section": "",
    "text": "So far in this course we have learned how to work interactively on the command line to analyse data. This section will introduce the idea of bash shell scripting. We will also introduce the concept of reproducible data analysis, and will show how using scripts to analyse data can facilitate this."
  },
  {
    "objectID": "06-scripts.html#shell-scripts-in-bash",
    "href": "06-scripts.html#shell-scripts-in-bash",
    "title": "Scripting for reproducible data analysis",
    "section": "Shell scripts in bash",
    "text": "Shell scripts in bash\n\n\n\n\n Key points\n\n\nA shell script is a text file containing multiple commands, which can then be run from the command line as a single command\n\n\n\n\nWriting and running your own scripts\n\nIn its most basic form, a shell script is simply a text file containing a list of commands that is run in sequence from top to bottom. This kind of script can be run by providing it as an argument to the bash command, as in the following example:\n\n[USERNAME]@bifx-core2:~$ date\nThu 12 Nov 14:21:16 GMT 2020\n[USERNAME]@bifx-core2:~$ echo hello\nhello\n[USERNAME]@bifx-core2:~$ ls /homes/genomes/mouse/\nGRCm38  mm10  mm9  UCSC\n[USERNAME]@bifx-core2:~$ echo date > my_script.sh\n[USERNAME]@bifx-core2:~$ echo 'echo hello' >> my_script.sh\n[USERNAME]@bifx-core2:~$ echo 'ls /homes/genomes/mouse' >> my_script.sh\n[USERNAME]@bifx-core2:~$ cat my_script.sh\ndate\necho hello\nls /homes/genomes/mouse/\n[USERNAME]@bifx-core2:~$ bash my_script.sh\nThu 12 Nov 14:26:29 GMT 2020\nhello\nGRCm38  mm10  mm9  UCSC\n[USERNAME]@bifx-core2:~$\n\nIt is also possible to create a script that can be run as a standalone program rather than as an argument to bash. This involves two steps:\n\nAdd the line #!/bin/bash (known as a shebang line) as the first line of the file using a text editor\nUse the chmod command to make the file executable\n\nchmod a+x my_script.sh will change the permissions on the script so that any user can run it\n\n\nOnce these steps have been followed, it will be possible to execute the script using its path:\n\n[USERNAME]@bifx-core2:~$ cat my_script.sh\n#!/bin/bash\ndate\necho hello\nls /homes/genomes/mouse/\n[USERNAME]@bifx-core2:~$ ls -l ./my_script.sh\n-rwxrwxr-x 1 [USERNAME] [USERNAME] 0 Nov 13 21:40 my_script.sh\n[USERNAME]@bifx-core2:~$ ./my_script.sh\nThu 12 Nov 14:26:29 GMT 2020\nhello\nGRCm38  mm10  mm9  UCSC\n[USERNAME]@bifx-core2:~$ \n\nNote: If you want to be able to run your script just by typing its name, you need to move it to a directory that is included in the $PATH environment variable.\n\nTo check which folders are listed in $PATH, you can type echo $PATH\nTo add a directory to $PATH permanently, add the line export PATH=[YOUR DIRECTORY]:$PATH to the end of the ~/.bashrc file, then run the command source ~/.bashrc\nIf you run a program from a directory in $PATH, it can be useful to check the full path to that program to make sure you’re not inadvertently running another program with the same name. You can do this by using the which command.\n\n\n\n\nEditing scripts\n\nYou can edit your scripts using a text editor such as emacs or vim.\n\nemacs opens emacs\n\nyou can then take the tutorial by typing Ctrl+h t\n\nvim opens vim\n\nyou can take a tutorial by running the vimtutor command at the bash prompt"
  },
  {
    "objectID": "06-scripts.html#reproducible-data-analysis-with-scripts",
    "href": "06-scripts.html#reproducible-data-analysis-with-scripts",
    "title": "Scripting for reproducible data analysis",
    "section": "Reproducible data analysis with scripts",
    "text": "Reproducible data analysis with scripts\n\n\n\n\n Key points\n\n\nData analysis should be reproducible\n\nYou should be able to recreate all of the steps in your analysis\nOther researchers should also be able to recreate your analysis to verify your results\n\nThe bash shell makes it easy to analyse data interactively. However, if data is analysed this way it can be difficult to keep track of exactly which steps were taken to produce a given result\nThis problem can be solved by creating a script that contains all of the commands needed to produce the results\n\nYou and other researchers can then recreate your analysis by running the script\n\nThis section presents a bash script that replicates the case study performed in the previous section\n\n\n\nIn the previous section we showed how to perform a simple analysis of some RNA-Seq data from scratch. In order turn this into a reproducible analysis workflow, it is necessary to put all of the commands that make up the analysis into a script.\n\n\nCreating a simple data analysis script\n\nThe simplest way to create a script is to put all of the commands that made up the analysis into a file in the order in which they were run, creating a file that looks like this:\n\nmkdir analysis\ncd analysis\nmkdir 00_source_data\ncd 00_source_data\nln -s ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\ncd ..\ntree\nmkdir 01_star_index\ncd 01_star_index\nln -s ../../bioinformatics_on_the_command_line_files/yeast_genome.fasta\nnice STAR --runThreadN 5 --runMode genomeGenerate --genomeDir . --genomeFastaFiles ./yeast_genome.fasta --genomeSAindexNbases 10\ncd ..\ntree\nmkdir 02_aligned_reads\ncd 02_aligned_reads\nnice STAR --genomeDir ../01_star_index/ --readFilesIn ../00_source_data/raw_yeast_rnaseq_data.fastq --runThreadN 5 --outFileNamePrefix raw_yeast_rnaseq_data. --outSAMtype BAM SortedByCoordinate\ncd ..\ntree\nmkdir 03_coverage\ncd 03_coverage\nbedtools genomecov -ibam ../02_aligned_reads/raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam > raw_yeast_rnaseq_data.genomecov.bg\ncd ..\ntree\nmkdir 04_gene_overlap_counts\ncd 04_gene_overlap_counts\nln -s ../../bioinformatics_on_the_command_line_files/yeast_genes.fixed.bed\nbedtools intersect -c -a yeast_genes.fixed.bed -b ../02_aligned_reads/raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam | awk -F'\\t' '$7>0' | sort -k7,7nr > raw_yeast_overlap_data.gene_overlap_counts.bed\ncd ..\ntree\nhead -10 04_gene_overlap_counts/raw_yeast_overlap_data.gene_overlap_counts.bed\ncd ..\n\nWe can see that this works by running the above file (which is saved on the server as ‘/library/training/bioinformatics_on_the_command_line/analysis_raw.sh’):\n\n[USERNAME]@bifx-core2:~/course$ ls\nanalysis  bioinformatics_on_the_command_line_files  bioinformatics_on_the_command_line_files.tar.gz\n[USERNAME]@bifx-core2:~/course$ mv analysis interactive_analysis\n[USERNAME]@bifx-core2:~/course$ ls\nbioinformatics_on_the_command_line_files  bioinformatics_on_the_command_line_files.tar.gz  interactive_analysis\n[USERNAME]@bifx-core2:~/course$ bash /library/training/bioinformatics_on_the_command_line/analysis_raw.sh\n.\n└── 00_source_data\n    └── raw_yeast_rnaseq_data.fastq -> ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n\n1 directory, 1 file\nNov 16 16:23:45 ..... started STAR run\nNov 16 16:23:45 ... starting to generate Genome files\nNov 16 16:23:46 ... starting to sort Suffix Array. This may take a long time...\nNov 16 16:23:46 ... sorting Suffix Array chunks and saving them to disk...\nNov 16 16:23:54 ... loading chunks from disk, packing SA...\nNov 16 16:23:55 ... finished generating suffix array\nNov 16 16:23:55 ... generating Suffix Array index\nNov 16 16:23:56 ... completed Suffix Array index\nNov 16 16:23:56 ... writing Genome to disk ...\nNov 16 16:23:56 ... writing Suffix Array to disk ...\nNov 16 16:23:57 ... writing SAindex to disk\nNov 16 16:23:57 ..... finished successfully\n.\n├── 00_source_data\n│   └── raw_yeast_rnaseq_data.fastq -> ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n└── 01_star_index\n    ├── chrLength.txt\n    ├── chrNameLength.txt\n    ├── chrName.txt\n    ├── chrStart.txt\n    ├── Genome\n    ├── genomeParameters.txt\n    ├── Log.out\n    ├── SA\n    ├── SAindex\n    └── yeast_genome.fasta -> ../../bioinformatics_on_the_command_line_files/yeast_genome.fasta\n\n2 directories, 11 files\nNov 16 16:23:57 ..... started STAR run\nNov 16 16:23:57 ..... loading genome\nNov 16 16:23:57 ..... started mapping\nNov 16 16:24:00 ..... finished mapping\nNov 16 16:24:00 ..... started sorting BAM\nNov 16 16:24:00 ..... finished successfully\n.\n├── 00_source_data\n│   └── raw_yeast_rnaseq_data.fastq -> ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n├── 01_star_index\n│   ├── chrLength.txt\n│   ├── chrNameLength.txt\n│   ├── chrName.txt\n│   ├── chrStart.txt\n│   ├── Genome\n│   ├── genomeParameters.txt\n│   ├── Log.out\n│   ├── SA\n│   ├── SAindex\n│   └── yeast_genome.fasta -> ../../bioinformatics_on_the_command_line_files/yeast_genome.fasta\n└── 02_aligned_reads\n    ├── raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam\n    ├── raw_yeast_rnaseq_data.Log.final.out\n    ├── raw_yeast_rnaseq_data.Log.out\n    ├── raw_yeast_rnaseq_data.Log.progress.out\n    ├── raw_yeast_rnaseq_data.SJ.out.tab\n    └── raw_yeast_rnaseq_data._STARtmp\n        └── BAMsort\n            ├── 0\n            ├── 1\n            ├── 2\n            ├── 3\n            └── 4\n\n10 directories, 16 files\n.\n├── 00_source_data\n│   └── raw_yeast_rnaseq_data.fastq -> ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n├── 01_star_index\n│   ├── chrLength.txt\n│   ├── chrNameLength.txt\n│   ├── chrName.txt\n│   ├── chrStart.txt\n│   ├── Genome\n│   ├── genomeParameters.txt\n│   ├── Log.out\n│   ├── SA\n│   ├── SAindex\n│   └── yeast_genome.fasta -> ../../bioinformatics_on_the_command_line_files/yeast_genome.fasta\n├── 02_aligned_reads\n│   ├── raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam\n│   ├── raw_yeast_rnaseq_data.Log.final.out\n│   ├── raw_yeast_rnaseq_data.Log.out\n│   ├── raw_yeast_rnaseq_data.Log.progress.out\n│   ├── raw_yeast_rnaseq_data.SJ.out.tab\n│   └── raw_yeast_rnaseq_data._STARtmp\n│       └── BAMsort\n│           ├── 0\n│           ├── 1\n│           ├── 2\n│           ├── 3\n│           └── 4\n└── 03_coverage\n    └── raw_yeast_rnaseq_data.genomecov.bg\n\n11 directories, 17 files\n.\n├── 00_source_data\n│   └── raw_yeast_rnaseq_data.fastq -> ../../bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n├── 01_star_index\n│   ├── chrLength.txt\n│   ├── chrNameLength.txt\n│   ├── chrName.txt\n│   ├── chrStart.txt\n│   ├── Genome\n│   ├── genomeParameters.txt\n│   ├── Log.out\n│   ├── SA\n│   ├── SAindex\n│   └── yeast_genome.fasta -> ../../bioinformatics_on_the_command_line_files/yeast_genome.fasta\n├── 02_aligned_reads\n│   ├── raw_yeast_rnaseq_data.Aligned.sortedByCoord.out.bam\n│   ├── raw_yeast_rnaseq_data.Log.final.out\n│   ├── raw_yeast_rnaseq_data.Log.out\n│   ├── raw_yeast_rnaseq_data.Log.progress.out\n│   ├── raw_yeast_rnaseq_data.SJ.out.tab\n│   └── raw_yeast_rnaseq_data._STARtmp\n│       └── BAMsort\n│           ├── 0\n│           ├── 1\n│           ├── 2\n│           ├── 3\n│           └── 4\n├── 03_coverage\n│   └── raw_yeast_rnaseq_data.genomecov.bg\n└── 04_gene_overlap_counts\n    ├── raw_yeast_overlap_data.gene_overlap_counts.bed\n    └── yeast_genes.fixed.bed -> ../../bioinformatics_on_the_command_line_files/yeast_genes.fixed.bed\n\n12 directories, 19 files\nXII 460922  466869  RDN37-2 .   -   3730\nXII 451785  457732  RDN37-1 .   -   3582\nXII 468812  468931  RDN5-2  .   +   3063\nXII 468826  468958  YLR154C-H   .   -   3063\nXII 472464  472583  RDN5-3  .   +   3060\nXII 472478  472610  YLR156C-A   .   -   3060\nXII 482044  482163  RDN5-4  .   +   3055\nXII 482058  482190  YLR157C-C   .   -   3055\nXII 485696  485815  RDN5-5  .   +   3052\nXII 485710  485842  YLR159C-A   .   -   3052\n\n[USERNAME]@bifx-core2:~/course$ \n\n\n\n\nCreating an improved data analysis script\n\nIn this section we improve our script by doing the following:\n\nAdding a shebang line to the script so that it can be run as a standalone program\nEnsuring that the script does not keep running if one of the commands within it fails\n\nThis is what the set -euo pipefail command at the top of the script does\n\nDeleting unnecessary commands\nAdding spacing and comments to make the script easier to read\n\nIn bash, lines starting with # are taken to be comments\n\nSpecifying inputs as variables in order to make the script more general and easier to maintain, and using paths relative to ‘~’ rather than the current working directory so that the script can be run in any directory and will still find the files\nAdding a few lines to the script to create a run report, which specifies the software versions used for the analysis\n\nThe updated script is shown here:\n\n#!/bin/bash\n# This is simple RNA-Seq analysis workflow that does the following:\n# - Creates a STAR index for the genome fasta file specified in the variable GENOME_FASTA\n# - Aligns the raw reads specified in the fastq file referenced by the variable RAW_FASTQ\n# - Computes the genome coverage of the aligned reads, producing a bedGraph file\n# - Counts the overlaps over the genes specified in the file referenced by the variable GENES_BED\n\nset -euo pipefail\n\n\n# Global variables ----\n\nRAW_FASTQ='~/course/bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq'\nGENOME_FASTA='~/course/bioinformatics_on_the_command_line_files/yeast_genome.fasta'\nGENES_BED='~/course/bioinformatics_on_the_command_line_files/yeast_genes.fixed.bed'\n\nls \"$RAW_FASTQ\" \"$GENOME_FASTA\" \"$GENES_BED\" > /dev/null\n\nRAW_FASTQ_BASENAME_PREFIX=`basename $RAW_FASTQ .fastq`\nGENOME_FASTA_BASENAME=`basename $GENOME_FASTA`\n\nTHREADS=5\n\n\n# Pipeline commands ----\n\n# Create a directory for the results of the analysis\n\nmkdir analysis\ncd analysis\n\n# Link to the fastq containing the raw sequences in '00_source_data'\n\nmkdir 00_source_data\ncd 00_source_data\nln -s \"$RAW_FASTQ\"\ncd ..\n\n# Create a STAR index for the genome fasta file, storing all of the results in '01_star_index'\n\necho 'Creating STAR index...'\n\nmkdir 01_star_index\ncd 01_star_index\nln -s \"$GENOME_FASTA\"\nnice STAR --runThreadN \"$THREADS\" --runMode genomeGenerate --genomeDir . --genomeFastaFiles \"$GENOME_FASTA_BASENAME\" --genomeSAindexNbases 10\ncd ..\n\n# Align the raw sequences using STAR, storing all of the results in '02_aligned_reads'\n\necho 'Aligning raw reads...'\n\nmkdir 02_aligned_reads\ncd 02_aligned_reads\nnice STAR --genomeDir ../01_star_index/ --readFilesIn ../00_source_data/\"$RAW_FASTQ_BASENAME_PREFIX\".fastq --runThreadN \"$THREADS\" --outFileNamePrefix \"$RAW_FASTQ_BASENAME_PREFIX\". --outSAMtype BAM SortedByCoordinate\ncd ..\n\n# Create a genome coverage file in bedGraph format, and store it in '03_coverage'\n\necho 'Creating genome coverage file...'\n\nmkdir 03_coverage\ncd 03_coverage\nbedtools genomecov -ibam ../02_aligned_reads/\"$RAW_FASTQ_BASENAME_PREFIX\".Aligned.sortedByCoord.out.bam > \"$RAW_FASTQ_BASENAME_PREFIX\".genomecov.bg\ncd ..\n\n# Compute the gene overlap counts, and store them as a bed file in '04_gene_overlap_counts'\n\necho 'Computing gene overlap counts...'\n\nmkdir 04_gene_overlap_counts\ncd 04_gene_overlap_counts\nln -s ../../bioinformatics_on_the_command_line_files/yeast_genes.fixed.bed\nbedtools intersect -c -a \"$GENES_BED\" -b ../02_aligned_reads/\"$RAW_FASTQ_BASENAME_PREFIX\".Aligned.sortedByCoord.out.bam | awk -F'\\t' '$7>0' | sort -k7,7nr > \"$RAW_FASTQ_BASENAME_PREFIX\".gene_overlap_counts.bed\ncd ..\n\n# Create a run report\n\necho `realpath $0`\" run completed successfully.\" > run_report.txt\ndate >> run_report.txt\necho 'Software versions:' >> run_report.txt\necho 'STAR' >> run_report.txt\nSTAR --version >> run_report.txt\necho 'bedtools' >> run_report.txt\nbedtools --version | sed 's/^bedtools //' >> run_report.txt\necho 'sort' >> run_report.txt\nsort --version | sed 's/^sort //' | head -1 >> run_report.txt\necho 'awk' >> run_report.txt\nawk --version | head -1 >> run_report.txt\n\n# If we've got here the pipeline has completed successfully\n\necho 'Pipeline completed successfully.'\n\nAgain, we can see that this works by running the above file (which is saved on the server as ‘/library/training/bioinformatics_on_the_command_line/analysis_improved.sh’):\n\n[USERNAME]@bifx-core2:~/course$ ls\nanalysis  bioinformatics_on_the_command_line_files  bioinformatics_on_the_command_line_files.tar.gz interactive_analysis\n[USERNAME]@bifx-core2:~/course$ mv analysis analysis_raw\n[USERNAME]@bifx-core2:~/course$ ls\nanalysis_raw                              bioinformatics_on_the_command_line_files.tar.gz\nbioinformatics_on_the_command_line_files  interactive_analysis\n[USERNAME]@bifx-core2:~/course$ bash /library/training/bioinformatics_on_the_command_line/analysis_improved.sh\nCreating STAR index...\nNov 16 16:38:09 ..... started STAR run\nNov 16 16:38:09 ... starting to generate Genome files\nNov 16 16:38:10 ... starting to sort Suffix Array. This may take a long time...\nNov 16 16:38:10 ... sorting Suffix Array chunks and saving them to disk...\nNov 16 16:38:18 ... loading chunks from disk, packing SA...\nNov 16 16:38:19 ... finished generating suffix array\nNov 16 16:38:19 ... generating Suffix Array index\nNov 16 16:38:20 ... completed Suffix Array index\nNov 16 16:38:20 ... writing Genome to disk ...\nNov 16 16:38:20 ... writing Suffix Array to disk ...\nNov 16 16:38:21 ... writing SAindex to disk\nNov 16 16:38:21 ..... finished successfully\nAligning raw reads...\nNov 16 16:38:21 ..... started STAR run\nNov 16 16:38:21 ..... loading genome\nNov 16 16:38:21 ..... started mapping\nNov 16 16:38:24 ..... finished mapping\nNov 16 16:38:24 ..... started sorting BAM\nNov 16 16:38:24 ..... finished successfully\nCreating genome coverage file...\nComputing gene overlap counts...\nPipeline completed successfully.\n[USERNAME]@bifx-core2:~/course$ cat analysis/run_report.txt\n/library/training/bioinformatics_on_the_command_line/analysis_improved.sh run completed successfully.\nMon 16 Nov 16:38:36 GMT 2020\nSoftware versions:\nSTAR\n2.7.3a\nbedtools\nv2.27.0\nsort\n(GNU coreutils) 8.28\nawk\nGNU Awk 4.1.4, API: 1.1 (GNU MPFR 4.0.1, GNU MP 6.1.2)\n[USERNAME]@bifx-core2:~/course$ \n\n\n\n\n Challenge:\n\nWhat is the line ls \"$RAW_FASTQ\" \"$GENOME_FASTA\" \"$GENES_BED\" > /dev/null in the script for?\n\n\n\n\nSolution. \n\n Solution:\n\nIf the files referenced by RAW_FASTQ, GENOME_FASTA, and GENES_BED exist, the line does nothing, as the output of the command is redirected to /dev/null (which basically means that it is ignored). However, if any of the files don’t exist this command will fail with an error message. Because we have included the line set -eou pipefail this will cause the script to stop running, which is what we want if one or more of the output files is missing.\n\n\n\n\n\n\nManaging your scripts\n\nOnce you start writing scripts, it is a good idea to use a version control system to keep track of the changes you make to your scripts. A good choice for this would be git. The following five commands will allow you to use git for version control:\n\ngit init to initialise a git repository in the current working directory\ngit add -A; git commit -m \"Latest updates\" to commit any changes to files in the current working directory to the repository\ngit status to see if any changes have been made since the last commit\ngit diff to see the differences between the files in the current working directory and the last commit\ngit show HEAD:[NAME OF FILE IN GIT] to view the most recent version of a file in the git repository\n\nYou can save the output of git show to a file by redirecting its output using >\n\n\nTo learn more about git, you can look at this software carpentry course, which covers it in a lot more detail.\nNote: git should only be used for small text files such as scripts. It is not designed to work with large data files.\n\n\n\nClosing thoughts: practical workflows on the command line\n\nIn this section we created a data analysis script in bash that satisfies two major requirements for reproducible data analysis:\n\nThe script provides a complete and accurate record of the steps that were taken to produce the output files, along with a record of the versions of the software tools used to manipulate the data\nThe script is also in a form that would be easy to share with other researchers, allowing them to replicate your analysis easily\n\nThe main drawback of using bash scripts to represent workflows is that they are often impractical. The example presented here uses an extremely small input FASTQ file, and an organism with a relatively small genome. As a result it can be run from scratch in under a minute. Running the same pipeline with a realistically sized input FASTQ file and a larger genome could take hours to run, so it is no longer practical to re-run the pipeline every time you make a change. A workaround for this would be to comment out parts of the script that you do not want to re-run, however this is considered bad practice as it introduces the possibility of human error in selecting the parts of the pipeline that need to be re-run when the pipeline is updated.\nIf you are writing analysis pipelines, you should look into using a modern workflow system such as Snakemake or Nextflow. Workflows written for these workflow systems can be run repeatedly, and the workflow system will automatically work out which steps of the analysis workflow need to be re-run based on the timestamps of the files. They also provide a number of other useful features:\n\nThey work out which steps of the analysis workflow can be run in parallel, and assign steps to different cores when possible, which can speed up the analysis considerably\nThey simplify the process of running workflows on a computing cluster"
  },
  {
    "objectID": "02-filesystem.html",
    "href": "02-filesystem.html",
    "title": "Working with the file system",
    "section": "",
    "text": "In this section you will learn how to explore the Linux file system, and how to create, move, delete and edit files and directories.\n\n\nIntroducing the Linux file system\n\n\n\n\n Key Points\n\n\nIn Linux, like other operating systems, the file system is stuctured as a tree\n\nThe top level directory is known as the root directory, and is referred to on the command line as /\n\nThe file system contains regular files, directories, and symbolic links to other files\n\nEach file has a unique path in the file system, along with other attributes such as its size, when it was last modified, and the permissions associated with it\n\nEach user’s files are generally stored in a directory called the user’s home directory, also referred to as ~\n\nHome directories are normally found in /home, however on the bifx servers user home directories are also found in /homes and /homes2\n\nbash keeps track of the current working directory that the shell is in\n\nWhen a user logs in to a Linux system, it starts in the user’s own home directory by default\n\n\n\n\n\nThe Linux file system\n\n\n\nThe Linux file system, where all files in a Linux system are stored, is structured as a tree with a single root directory, known as /, as shown in the above image. The root directory has a number of subdirectories. The most important for us on the bifx servers are the /homes and /homes2 folders, as these are where users’ home directories are stored. Each user’s files are generally stored in their home directory, and by default users on the bifx servers are not permitted to create files outside their own home directory. You can find out the path to your home directory by running the command echo $HOME.\n\n\n\nFile paths in Linux\n\nFile paths in Linux can be either absolute paths, or relative paths.\n\n\nAbsolute paths\nEach file in the Linux file system tree is uniquely identified by its absolute path. The absolute path comprises a list of the parent directories of the file, starting from the root directory, separated by the / character, followed by the name of the file. The name of a file, and the path to its parent directory, can be extracted from its path using the basename and dirname commands:\n\n[USERNAME]@bifx-core2:~$ basename /library/training/bioinformatics_on_the_command_line\nbioinformatics_on_the_command_line\n[USERNAME]@bifx-core2:~$ dirname /library/training/bioinformatics_on_the_command_line\n/library/training\n[USERNAME]@bifx-core2:~$ \n\nIn Linux file names can contain almost any character other than /. However, many characters, including spaces and special characters such as ’ and “, can make files difficult to work with, so, in general, it’s better to stick with letters, numbers, underscores, dashes, and dots when naming files. If you do have to work with a file that contains special characters, you can either put the file path in quotes or use backslashes to escape the special characters:\n\n[USERNAME]@bifx-core2:~$ basename /library/training/bioinformatics_on_the_command_line/file name with spaces\nbasename: extra operand ‘with’\nTry 'basename --help' for more information.\n[USERNAME]@bifx-core2:~$ basename '/library/training/bioinformatics_on_the_command_line/file name with spaces'\nfile name with spaces\n[USERNAME]@bifx-core2:~$ basename /library/training/bioinformatics_on_the_command_line/file\\ name\\ with\\ spaces\nfile name with spaces\n[USERNAME]@bifx-core2:~$\n\nNote: Tab completion works with filenames as well as command names.\nThe pwd command shows the absolute path of the current working directory:\n\n[USERNAME]@bifx-core2:~$ pwd\n/homes/[USERNAME]\n[USERNAME]@bifx-core2:~$\n\n\n\n\nRelative paths\nWhile absolute paths provide an unambiguous way of referring to files, they can be cumbersome. For this reason, Linux makes it possible to define paths relative to the current working directory or the user’s home directory:\n\n~ refers to the user’s home directory\n. refers to the current working directory\n.. refers to the parent directory of the current working directory\n\n../.. refers to the parent directory of the parent directory of the current working directory, ../../.. refers to the parent directory of that directory, and so on\n\n\nIf you just use the name of a file, Linux assumes that you are referring to a file in the current working directory.\nThe realpath command can be used to show the absolute path corresponding to a relative path:\n\n[USERNAME]@bifx-core2:~$ realpath ~\n/homes/[USERNAME]\n[USERNAME]@bifx-core2:~$ realpath .\n/homes/[USERNAME]\n[USERNAME]@bifx-core2:~$ realpath ..\n/homes\n[USERNAME]@bifx-core2:~$ \n\n\n\n\nGlob patterns\nLinux also makes it possible to include wildcards in file paths, making it possible to refer to a group of file paths at once. Paths that include wildcards are called glob patterns. Useful wildcards include:\n\n* which matches any sequence of characters\n? which matches any single character\n[] which matches a single character within the square brackets\n\nfor example, [aA] would match ‘a’ or ‘A’\nranges of numbers are allowed, so [1-5] matches 1, 2, 3, 4, or 5\n\n\nWhen bash sees a glob pattern, it expands it into a list of file paths that match the pattern (separated by spaces). A convenient way to experiment with glob patterns (and to make sure they match the files you want them to) is to use the echo command, which prints its arguments to the command line:\n\n[USERNAME]@bifx-core2:~$ echo /homes/genomes/mouse/*\n/homes/genomes/mouse/GRCm38 /homes/genomes/mouse/mm10 /homes/genomes/mouse/mm9 /homes/genomes/mouse/UCSC\n[USERNAME]@bifx-core2:~$ echo /homes/genomes/mouse/mm?\n/homes/genomes/mouse/mm9\n[USERNAME]@bifx-core2:~$ echo /homes/genomes/mouse/mm*\n/homes/genomes/mouse/mm10 /homes/genomes/mouse/mm9\n[USERNAME]@bifx-core2:~$\n\nNote: If you write an argument to a command that contains glob wildcard characters, but is not a glob pattern, always remember to put it in quotes to prevent it from being expanded by the shell. It’s also worth remembering that glob patterns do not match files that start with a dot. These are hidden files and are often used as configuration files that users do not normally need to see.\n\n\n\n\nFile types and attributes in Linux\n\nThe Linux file system contains a three main types of file:\n\nRegular files, which contain data\nDirectories, which contain other files or directories\nSymbolic links, which are aliases for files and folders\n\nAs well as its name and path, each file has a number of attributes associated with it, such as its size, when it was last modified, and the permissions associated with it. You can check the attributes associated with a file using the stat command:\n\n[USERNAME]@bifx-core2:~$ stat /library/training/bioinformatics_on_the_command_line/bioinformatics_on_the_command_line_files.tar.gz\n  File: /library/training/bioinformatics_on_the_command_line/bioinformatics_on_the_command_line_files.tar.gz\n  Size: 4059820     Blocks: 7975       IO Block: 8192   regular file\nDevice: 37h/55d Inode: 13189       Links: 1\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2020-11-12 12:56:58.543765691 +0000\nModify: 2020-11-12 12:53:47.358367501 +0000\nChange: 2020-11-12 12:56:31.032140047 +0000\n Birth: -\n[USERNAME]@bifx-core2:~$\n\nThe output of the stat command shows us:\n\nWhat type of file this is (a regular file)\nThe size of the file (4059820)\nThe identity and group of the owner of the file (root)\nWhen the file was last accessed, modified, and changed\nThe permissions on the file (-rw-r–r–)\n\nThe first character of the permission string tells us whether it is a file or directory\nThe rest of the string can be divided into three groups (rw-, r–, and r–), representing the permissions granted to the user that owns the file, the group associated with the file, and all users\nThere are three types of permission. These are permission to read the file (r), permission to write to the file (w), and permission to execute the file (x)\n\n\nNote: When you run the stat command on a directory it shows the size of the directory itself, not the size of the directory with all of its contents (which is normally what you want). To find the size of a directory and its contents, you can use the du -sh command:\n\n[USERNAME]@bifx-core2:~$ stat /library/training/bioinformatics_on_the_command_line\n  File: /library/training/bioinformatics_on_the_command_line\n  Size: 4           Blocks: 41         IO Block: 4096   directory\nDevice: 37h/55d Inode: 13190       Links: 2\nAccess: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2020-11-13 10:21:45.604446040 +0000\nModify: 2020-11-12 22:13:44.568434982 +0000\nChange: 2020-11-12 22:13:44.568434982 +0000\n Birth: -\n[USERNAME]@bifx-core2:~$ du -sh /library/training/bioinformatics_on_the_command_line \n4.0M    /library/training/bioinformatics_on_the_command_line\n[USERNAME]@bifx-core2:~$ \n\n\n\n\n Challenge:\n\nCreate a glob pattern that matches /homes/genomes/mouse/GRCm38 and /homes/genomes/mouse/UCSC only.\n\n\n\n\nSolution. \n\n Solution:\n\nOne option would be /homes/genomes/mouse/[GU]*\n\n\n\n\n\n\n Challenge:\n\nCreate a glob pattern that matches everything in /homes/genomes/mouse except for /homes/genomes/mouse/UCSC.\n\n\n\n\nSolution. \n\n Solution:\n\nOne option would be /homes/genomes/mouse/*[0-9]\n\n\n\n\n\n\n Challenge:\n\nWho has permission to read the file ‘/library/training/bioinformatics_on_the_command_line/bioinformatics_on_the_command_line_files.tar.gz’? Who is permitted to write to it? Is anyone permitted to execute it?\n\n\n\n\nSolution. \n\n Solution:\n\nEveryone on the server can read the file. The user that owns the file can read and write to it. Nobody is permitted to execute this file.\n\n\n\n\n\n\n\nExploring the file system\n\n\n\n\n Key Points\n\n\ncd changes the current working directory\npushd also changes the current working directory, but keeps a history of where you’ve been\n\nUse popd to go back, and dirs to look at the history\n\nThe ls command lists the files in the current working directory\nThe tree command provides a readable summary of the files in the current directory and its subdirectories\nThe find command recursively searches for files in the current file system\n\n\n\nThe following example demonstrates how we can navigate within the file system, and view and find files:\n\n[USERNAME]@bifx-core2:~$ cd /library/training/bioinformatics_on_the_command_line \n[USERNAME]@bifx-core2:/library/training/bioinformatics_on_the_command_line$ ls\nanalysis_improved.sh   analysis_raw.sh   bioinformatics_on_the_command_line_files.tar.gz  'file name with spaces'\n[USERNAME]@bifx-core2:/library/training/bioinformatics_on_the_command_line$ ls -lah\ndrwxr-xr-x 2 root root    6 Nov 16 12:53  .\ndrwxr-xr-x 3 root root    3 Nov 12 12:56  ..\n-rwxr-xr-x 1 root root 3.2K Nov 16 12:54  analysis_improved.sh\n-rw-r--r-- 1 root root 1.3K Nov 16 12:53  analysis_raw.sh\n-rw-r--r-- 1 root root 3.9M Nov 12 12:53  bioinformatics_on_the_command_line_files.tar.gz\n-rw-r--r-- 1 root root    0 Nov 12 21:58 'file name with spaces'\n[USERNAME]@bifx-core2:/library/training/bioinformatics_on_the_command_line$ ls -lah *.gz\n-rw-r--r-- 1 root root 3.9M Nov 12 12:53 bioinformatics_on_the_command_line_files.tar.gz\n[USERNAME]@bifx-core2:/library/training/bioinformatics_on_the_command_line$ pushd /homes/genomes/\n/homes/genomes /library/training/bioinformatics_on_the_command_line\n[USERNAME]@bifx-core2:/homes/genomes$ pushd /library/training/\n/library/training /homes/genomes /library/training/bioinformatics_on_the_command_line\n[USERNAME]@bifx-core2:/library/training$ dirs\n/library/training /homes/genomes /library/training/bioinformatics_on_the_command_line\n[USERNAME]@bifx-core2:/library/training$ tree\n.\n└── bioinformatics_on_the_command_line\n    ├── analysis_improved.sh\n    ├── analysis_raw.sh\n    ├── bioinformatics_on_the_command_line_files.tar.gz\n    └── file name with spaces\n\n1 directory, 4 files\n[USERNAME]@bifx-core2:/library/training$ popd\n/homes/genomes /library/training/bioinformatics_on_the_command_line\n[USERNAME]@bifx-core2:/homes/genomes$ find ./mouse/mm10/ -type f -name '*.bed'\n./mouse/mm10/mm10_repeat_masker.bed\n./mouse/mm10/mm10-liftover-blacklist.bed\n./mouse/mm10/annotation/GSE17051_cLAD_regions.mm10.bed\n./mouse/mm10/annotation/Mus_musculus.GRCm38.79.edited.bed\n./mouse/mm10/annotation/mm10_cgi.liftover.bed\n./mouse/mm10/annotation/mm10-liftover-blacklist.bed\n./mouse/mm10/annotation/GSE17051_ciLAD_regions.mm10.bed\n./mouse/mm10/annotation/Ensembl.transcripts.bed\n./mouse/mm10/annotation/mm10.blacklist.bed\n./mouse/mm10/annotation/mm10-liftover-blacklist.OLD.bed\n./mouse/mm10/mm10repeats.bed\n[USERNAME]@bifx-core2:/homes/genomes$ popd\n/library/training/bioinformatics_on_the_command_line\n[USERNAME]@bifx-core2:/library/training/bioinformatics_on_the_command_line$ cd\n[USERNAME]@bifx-core2:~$ \n\nNote: In this example we have used the command ls -lah. This is an example of a shorthand that you can use in the bash shell when specifying multiple flags. ls -lah is equivalent to ls -l -a -h.\n\n\n\n Challenge:\n\nList all of the paths to files named ‘genome.fa’ in the directory ‘/homes/genomes/mouse/’\n\n\n\n\nSolution. \n\n Solution:\n\nRun find /homes/genomes/mouse/ -type f -name 'genome.fa'\n\n\n\n\n\n\n\n Challenge:\n\nUsing the commands you’ve learned in this section, explore the /homes/genomes/ directory on the server. Which organisms do we have genomes for (no need to include subdirectories)? Which genome releases do we have for each of these organisms? Are there any files in ’/homes/genomes/mouse over 6GB in size?\n\n\n\n\nSolution. \n\n Solution:\n\nRun ls /homes/genomes/ to list the organisms in ‘/homes/genomes’. Run find /homes/genomes/ -maxdepth 2 -type d to list the subdirectories of the directories representing the organisms, which represent genome releases. Run find /homes/genomes/mouse -type f -size +6G to list the files over 6GB in size.\n\n\n\n\n\n\nCreating and deleting files\n\n\n\n\n Key Points\n\n\nFiles can be created using touch, by a text editor, or by redirecting the output of a program\nSymbolic links can be created using ln -s\nDirectories can be created using mkdir, and empty directories can be removed using rmdir\nThe rm command can be used to delete files, links, and directories along with their contents (using the -r flag)\n\nThere is no recycle bin in Linux, so rm should be used with care. The -i flag can be used to prompt for confirmation before deleting files\n\n\n\n\nThe following example demonstrates how we can create and remove files, directories and links:\n\n[USERNAME]@bifx-core2:~$ mkdir course\n[USERNAME]@bifx-core2:~$ cd course\n[USERNAME]@bifx-core2:~/course$ mkdir -p dir1 dir2 dir3/dir4\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── dir1\n├── dir2\n└── dir3\n    └── dir4\n    \n4 directories, 0 files\n[USERNAME]@bifx-core2:~/course$ touch file1\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── dir1\n├── dir2\n├── dir3\n│   └── dir4\n└── file1\n\n4 directories, 1 file\n[USERNAME]@bifx-core2:~/course$ cd dir1\n[USERNAME]@bifx-core2:~/course$ ln -s ../file1\n[USERNAME]@bifx-core2:~/course$ cd ..\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── dir1\n│   └── file1 -> ../file1\n├── dir2\n├── dir3\n│   └── dir4\n└── file1\n\n4 directories, 2 files\n[USERNAME]@bifx-core2:~/course$ rmdir *\nrmdir: failed to remove 'dir1': Directory not empty\nrmdir: failed to remove 'dir3': Directory not empty\nrmdir: failed to remove 'file1': Not a directory\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── dir1\n│   └── file1 -> ../file1\n├── dir3\n│   └── dir4\n└── file1\n\n3 directories, 2 files\n[USERNAME]@bifx-core2:~/course$ rm -ri *\nrm: descend into directory 'dir1'? y\nrm: remove symbolic link 'dir1/file1'? y\nrm: remove directory 'dir1'? n\nrm: descend into directory 'dir3'? y\nrm: remove directory 'dir3/dir4'? y\nrm: remove directory 'dir3'? y\nrm: remove regular empty file 'file1'? n\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── dir1\n└── file1\n\n1 directory, 1 file\n[USERNAME]@bifx-core2:~/course$ rmdir dir1\n[USERNAME]@bifx-core2:~/course$ rm -i file1\nrm: remove regular empty file 'file1'? y\n[USERNAME]@bifx-core2:~/course$ tree\n.\n\n0 directories, 0 files\n[USERNAME]@bifx-core2:~/course$\n\nThe example demonstrates a number of commands:\n\ntouch to create an empty file\n\nThis can also be used to update the timestamp on an existing file\n\nmkdir to create empty directories\n\nAdd -p to create nested directories by specifying paths\n\nln -s to create a symbolic link to a file or directory\nrmdir to delete empty directories, without deleting files or non-empty directories\nrm command\n\nAdd -r to remove directories (and their contents)\nAdd -i to ask for confirmation before deleting\n\n\n\n\n\n Challenge:\n\nHow could you create a symbolic link which has a different name to the file you’re linking to?\n\n\n\n\nSolution. \n\n Solution:\n\nUse ln -s -T [path to target file] [new name]\n\n\n\n\n\n\nCopying and moving files and directories\n\n\n\n\n Key Points\n\n\nFiles and directories can be copied using cp\n\nTo copy a directory along with its contents, use the -r flag\n\nArchive files in tar format can be extracted using the tar command\nDirectories can be synchronised using rsync, which only copies updated files\nFiles and directories can be moved or renamed using mv\n\nGroups of files can be renamed using prename\n\nAttributes of files and directories can be changed using chmod and touch\n\ntouch updates the timestamp of an existing file\nchmod changes the permissions on a file\n\n\n\n\nThe following example demonstrates how we can copy files and directories, extract archive files, synchronise directories, and update file permissions:\n\n[USERNAME]@bifx-core2:~/course$ cp /library/training/bioinformatics_on_the_command_line/bioinformatics_on_the_command_line_files.tar.gz ./\n[USERNAME]@bifx-core2:~/course$ tar xzvf bioinformatics_on_the_command_line_files.tar.gz\nbioinformatics_on_the_command_line_files/\nbioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\nbioinformatics_on_the_command_line_files/yeast_genome.fasta\nbioinformatics_on_the_command_line_files/README\nbioinformatics_on_the_command_line_files/yeast_genes.bed\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── bioinformatics_on_the_command_line_files\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── README\n│   ├── yeast_genes.bed\n│   └── yeast_genome.fasta\n└── bioinformatics_on_the_command_line_files.tar.gz\n\n1 directory, 5 files\n[USERNAME]@bifx-core2:~/course$ cp -a -r bioinformatics_on_the_command_line_files bioinformatics_on_the_command_line_files-copy\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── bioinformatics_on_the_command_line_files\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── README\n│   ├── yeast_genes.bed\n│   └── yeast_genome.fasta\n├── bioinformatics_on_the_command_line_files-copy\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── README.txt\n│   ├── yeast_genes.bed\n│   └── yeast_genome.fasta\n└── bioinformatics_on_the_command_line_files.tar.gz\n\n2 directories, 9 files\n[USERNAME]@bifx-core2:~/course$ mv bioinformatics_on_the_command_line_files-copy/README ./README.txt\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── bioinformatics_on_the_command_line_files\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── README\n│   ├── yeast_genes.bed\n│   └── yeast_genome.fasta\n├── bioinformatics_on_the_command_line_files-copy\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── yeast_genes.bed\n│   └── yeast_genome.fasta\n├── bioinformatics_on_the_command_line_files.tar.gz\n└── README.txt\n\n2 directories, 9 files\n[USERNAME]@bifx-core2:~/course$ rsync -av bioinformatics_on_the_command_line_files/ bioinformatics_on_the_command_line_files-copy/\nsending incremental file list\n./\nREADME\n\nsent 765 bytes  received 38 bytes  1,606.00 bytes/sec\ntotal size is 14,147,099  speedup is 17,617.81\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── bioinformatics_on_the_command_line_files\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── README\n│   ├── yeast_genes.bed\n│   └── yeast_genome.fasta\n├── bioinformatics_on_the_command_line_files-copy\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── README\n│   ├── yeast_genes.bed\n│   └── yeast_genome.fasta\n├── bioinformatics_on_the_command_line_files.tar.gz\n└── README.txt\n\n2 directories, 10 files\n[USERNAME]@bifx-core2:~/course$ prename 's/yeast/s.cerevisiae/' bioinformatics_on_the_command_line_files-copy/*\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── bioinformatics_on_the_command_line_files\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── README\n│   ├── yeast_genes.bed\n│   └── yeast_genome.fasta\n├── bioinformatics_on_the_command_line_files-copy\n│   ├── raw_s.cerevisiae_rnaseq_data.fastq\n│   ├── README\n│   ├── s.cerevisiae_genes.bed\n│   └── s.cerevisiae_genome.fasta\n├── bioinformatics_on_the_command_line_files.tar.gz\n└── README.txt\n\n2 directories, 10 files\n[USERNAME]@bifx-core2:~/course$ rm -r -i bioinformatics_on_the_command_line_files-copy README.txt\nrm: descend into directory 'bioinformatics_on_the_command_line_files-copy/'? y\nrm: remove regular file 'bioinformatics_on_the_command_line_files-copy/s.cerevisiae_genome.fasta'? y\nrm: remove regular file 'bioinformatics_on_the_command_line_files-copy/raw_s.cerevisiae_rnaseq_data.fastq'? y\nrm: remove regular file 'bioinformatics_on_the_command_line_files-copy/README'? y\nrm: remove regular file 'bioinformatics_on_the_command_line_files-copy/s.cerevisiae_genes.bed'? y\nrm: remove directory 'bioinformatics_on_the_command_line_files-copy/'? y\nrm: remove regular file 'README.txt'? y\n[USERNAME]@bifx-core2:~/course$ tree\n.\n├── bioinformatics_on_the_command_line_files\n│   ├── raw_yeast_rnaseq_data.fastq\n│   ├── README\n│   ├── yeast_genes.bed\n│   └── yeast_genome.fasta\n└── bioinformatics_on_the_command_line_files.tar.gz\n\n1 directory, 5 files\n[USERNAME]@bifx-core2:~/course$ chmod a-w bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\n[USERNAME]@bifx-core2:~/course$ rm bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq\nrm: remove write-protected regular file 'bioinformatics_on_the_command_line_files/raw_yeast_rnaseq_data.fastq'? n\n[USERNAME]@bifx-core2:~/course$\n\nThis example has demonstrated a number of commands:\n\ncp to copy files and directories (with the -r flag set)\n\nThe -a flag preserves file attributes when they are copied\n\nrsync to synchronise directories\nmv to move files or directories\nprename to perform ‘search and replace’ style renaming of files\ntouch to update the timestamp of an existing file\nchmod to change the permissions on a file\n\nIt’s always a good idea to make raw data files read only as we did in the example, as it makes it more difficult to remove or overwrite them accidentally\n\n\n\n\n\n Challenge:\n\nHow would you change the permissions on a file so that nobody can execute it, and only the owner of the file can read it or write to it?\n\n\n\n\nSolution. \n\n Solution:\n\nYou can do this using the following steps:\n\n[USERNAME]@bifx-core2:~/course$ touch chmod_test\n[USERNAME]@bifx-core2:~/course$ ls -l chmod_test\n\n-rw-rw-r-- 1 [USERNAME] [USERNAME] 0 Nov 14 12:51 chmod_test\n[USERNAME]@bifx-core2:~/course$ chmod ugo-rwx chmod_test\n[USERNAME]@bifx-core2:~/course$ chmod u+rw chmod_test\n[USERNAME]@bifx-core2:~/course$ ls -l chmod_test\n\n-rw------- 1 [USERNAME] [USERNAME] 0 Nov 14 12:51 chmod_test\n[USERNAME]@bifx-core2:~/course$ \n\n\n\n\n\n\n\n Challenge:\n\nHow could you check which files rsync will copy across when synchronising folders without actually copying them?\n\n\n\n\nSolution. \n\n Solution:\n\nrsync has a --dry-run flag that allows you to do this."
  },
  {
    "objectID": "04-processes.html",
    "href": "04-processes.html",
    "title": "Working with processes",
    "section": "",
    "text": "In this section you will learn how to work with processes and jobs in bash."
  },
  {
    "objectID": "04-processes.html#exploring-processes",
    "href": "04-processes.html#exploring-processes",
    "title": "Working with processes",
    "section": "Exploring processes",
    "text": "Exploring processes\n\n\n\n\n Key points\n\n\nA running program is known as a process. On a modern computer many different processes can run at once\nProcesses are managed by the operating system (Linux in our case)\n\nThe operating system controls how the computer’s resources, such as CPU and disk access, are allocated to the different processes\n\n\n\n\nThere are a few different ways to explore the processes running on your computer:\n\nps shows the processes you are currently running\ntop shows all active processes\nhtop gives a user friendly representation of the processes currently running along with CPU and memory usage on the server\npgrep finds the process IDs of all running instances of a particular program\n\nWe can learn a lot about processes by looking at the output of these commands. For example, if we run the command ps -fly we get something like this:\n\n[USERNAME]@bifx-core2:~/course$ ps -fly\nS UID         PID   PPID   C  PRI  NI   RSS   SZ    WCHAN  STIME TTY          TIME CMD\nS [USERNAME]  35269 35244  0  80   0    39296 13648 wait   Nov10 pts/5    00:00:04 -bash\nR [USERNAME]  44935 35269  0  80   0    3328  8822  -      10:11 pts/5    00:00:00 ps -fly\n...\n\nBy looking at the output columns, we can see the following:\n\nEach process has an owner, whose username is shown in the UID column\nEach process has a unique ID, shown in the PID column\nEach process also has a single parent process, whose ID is shown in the PPID column\n\nThe parent of a process is the process that started it. In our case, the ps -fly process was started by the bash process\nYou can see this by observing that the PPID of the ps -fly process is the same as the PID of the bash process\n\n\n\n\n\n Challenge:\n\nUse htop to find the following:\n\n\nHow many cores does bifx-core2 have?\n\n\nHow much memory does it have?\n\n\nWhat is the parent process of the htop process?\n\n\n\n\n\n\nSolution. \n\n Solution:\n\nRun htop -u [USERNAME] to start htop and display only your own processes. At the top of the htop screen there is a bar chart style representation of each of the cores on the server, showing how busy each core is. bifx-core2 has 64 cores. There is also a bar entitled Mem, with the total memory shown to its right. bifx-core2 has 504G. To find the parent process of htop press F5 to see a tree view. Then press F3 and search for htop. The parent process is bash, visible above the htop process."
  },
  {
    "objectID": "04-processes.html#job-control",
    "href": "04-processes.html#job-control",
    "title": "Working with processes",
    "section": "Job control",
    "text": "Job control\n\n\n\n\n Key points\n\n\nA ‘job’ is a process that is managed by the bash shell, and is a child of the bash process\n\nIn general, whenever you run a command in bash, it starts a job\n\nThe shell keeps track of all of the jobs that it’s currently managing\nRunning a command starts it as a foreground job\n\nWhen a job is run in the foreground you are not shown another command prompt until the job completes.\n\nRunning a command followed by & starts it as a background job\n\nWhen a job is run in the background you are shown another command prompt immediately.\n\n\n\n\n\nControlling processes and jobs\n\nIn UNIX based systems, jobs and processes can be paused or stopped completely by sending them ‘signals’. There are many signals that you can send (type kill -l to list them all). Arguably the most important are the following:\n\nSIGINT, SIGHUP, and SIGTERM, which request that the process should terminate gracefully\n\nNot all programs respond to these signals. For instance, vim ignores the SIGINT signal\n\nSIGKILL, which terminates the process immediately\n\nThis should only be used as a last resort, as processes that are sent this signal will not be able close gracefully\n\nSIGTSTP, which suspends the process, and SIGCONT, which restarts a suspended process\n\n\n\nSending signals to jobs or processes\nThere are many ways to send signals to jobs. Here are some particularly useful ones:\n\nThe kill command sends a specified signal to an individual process or job by ID\n\njobs shows you the names and IDs of all of the jobs that you are currently running in your shell\nYou can also use killall to send a signal to all running instances of a given program, but this is generally a bad idea. It is better to use htop or a combination of pgrep and kill to ensure you only send a signal to the process that you want to\n\nPressing f9 in htop also allows you to send the signal of your choice to the selected process\n\nThere are also some useful keyboard shortcuts to send signals to jobs\n\nCtrl+c sends the SIGINT signal to the current foreground job\nCtrl+z sends the SIGTSTP signal to the current foreground job\n\n\n\n\nRestarting jobs\nOnce a job has been stopped, it can be restarted in a number of ways:\n\nfg [job ID] restarts a job in the foreground\nbg [job ID] restarts a job in the background\nSend the SIGCONT signal to the job using kill -CONT [job or process ID] or htop\n\n\n\n\nDisowing jobs\nBy default, jobs you start in your shell are ‘owned’ by your current shell session. As a result, on some servers the job might be terminated when you exit the shell (depending on how bash is configured). You can ensure that this does not happen by ‘disowning’ the job.\n\ndisown [job ID] disowns a currently running job\n\nonce a job has been disowned by the shell, it will disappear from the shell’s job table. The process will become a child of the top level process\n\nnohup can be used to start a job that will definitely not be sent a SIGHUP signal when the shell is closed\n\nUsing nohup also diverts any output that would have gone to the shell to a file called nohup.out\n\n\nThe following example shows how to move a foreground job to the background and disown it:\n\n[USERNAME]@bifx-core2:~/course$ sleep 10000\n<Ctrl+z>\n^Z\n[1]+  Stopped                 sleep 10000\n[USERNAME]@bifx-core2:~/course$ bg %1\n[1]+ sleep 10000 &\n[USERNAME]@bifx-core2:~/course$ jobs\n[1]+  Running                 sleep 10000 &\n[USERNAME]@bifx-core2:~/course$ disown %1\n[USERNAME]@bifx-core2:~/course$ jobs\n[USERNAME]@bifx-core2:~/course$ ps\n  PID TTY          TIME CMD\n29621 pts/1    00:00:00 sleep\n37480 pts/1    00:00:00 bash\n40951 pts/1    00:00:00 ps\n[USERNAME]@bifx-core2:~/course$ \n\nThe example shows that when the sleep 10000 job is disowned it is removed from the jobs list, but the process keeps running.\n\n\n\n Challenge:\n\nHow could you terminate a foreground job without using Ctrl+c?\n\n\n\n\nSolution. \n\n Solution:\n\nOne way would be to pause the job with Ctrl+z, and then use kill -INT [job ID] to send a SIGINT signal to the job\n\n\n\n\n\n\n Challenge:\n\nHow could you restart a stopped job that has been disowned?\n\n\n\n\nSolution. \n\n Solution:\n\nYou could use htop or ps to find the process IDs of the stopped processes, and then use kill -CONT [process ID] to send a SIGCONT signal to those processes."
  },
  {
    "objectID": "01-introduction.html",
    "href": "01-introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "This introductory course will teach you the basics of performing bioinformatics data analysis on the command line using the GNU bash shell. It covers the following topics:\n\nGetting started with bash\nRunning commands in bash\nNavigating the file system\nManaging files, directories and links\nManaging processes\nBioinformatics data analysis with bash\nCreating bash scripts for reproducible data analysis\n\n\n\nThe GNU bash shell\n\nThe GNU bash shell is one of a range of command line shells that are available for UNIX based operating systems. Modern alternatives include ZSH and the fish shell. Each of these shells provides a high level interface to UNIX based operating systems such as GNU/Linux.\nCommand line shells such as bash provide similar functionality to graphical user interfaces (GUIs), such as those seen in Microsoft Windows and Mac OS X, allowing users to do perform tasks such as navigating the file system, running programs, and managing processes and system settings.\n\n\n\nAdvantages of using a command line shell\n\nWhile command line shells such as bash are not as intuitive for beginners as the point and click interfaces offered by GUI shells, they offer a number of advantages which are very useful for Bioinformatics data analysis:\n\nFlexibility\n\nyou can log in and work on remote machines that may not have a graphical interface or remote desktop server installed\nyou can use bioinformatics tools that don’t have a GUI\n\nReliability\n\nCommand line interfaces take up less memory and system resources than graphical interfaces\nBecause of the complexity of GUI programming, tools with GUIs are more likely to contain bugs\n\nConvenience\n\nPrograms and documentation can be accessed easily\nbash keeps a history of the commands you run and makes it easy to repeat commands\n\nPower\n\nsimple programs can be combined to perform more complex functions\nyou can create scripts for data analysis, without the overhead of creating a GUI\n\n\n\n\n\nThe UNIX philosophy\n\nThe programs that you will use to interact with the computer using the GNU bash shell have been designed according to the UNIX philosophy, which has been summarised as follows:\n\nWrite programs that do one thing and do it well\nWrite programs to work together\nWrite programs to handle text streams, because that is a universal interface\n\nThis philosophy makes it possible to perform a wide range of complex data analysis tasks by combining a relatively small number of basic commands in different ways. Once you have mastered these basic commands, you’ll find that the bash shell provides an extremely powerful and useful way to manage bioinformatics analyses."
  }
]